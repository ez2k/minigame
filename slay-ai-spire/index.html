<!DOCTYPE html>

<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Slay AI Spire v2</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(180deg, #0d0d15 0%, #1a1020 50%, #0d0d15 100%);
      color: #e8e4d9;
      min-height: 100vh;
      overflow-x: hidden;
    }
    .hidden { display: none !important; }
    .gold { color: #d4af37; }
    .red { color: #dc143c; }
    .blue { color: #4a9eff; }
    .green { color: #4ade80; }
    .purple { color: #c084fc; }
    .muted { color: #888; }
    .center { text-align: center; }

```
.btn {
  display: inline-flex; align-items: center; justify-content: center;
  padding: 14px 28px; border: none; border-radius: 8px;
  font-size: 16px; font-weight: 600; cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
}
.btn:active { transform: scale(0.96); }
.btn-gold {
  background: linear-gradient(135deg, #b8860b, #d4af37, #f4d03f);
  color: #1a1a1a;
  box-shadow: 0 4px 20px rgba(212,175,55,0.3);
}
.btn-dark {
  background: rgba(255,255,255,0.1);
  color: #d4af37;
  border: 1px solid rgba(212,175,55,0.4);
}
.btn-green {
  background: linear-gradient(135deg, #166534, #22c55e);
  color: #fff;
}
.btn-sm { padding: 8px 16px; font-size: 14px; }
.btn:disabled { opacity: 0.5; cursor: not-allowed; }

.top-bar {
  position: fixed; top: 0; left: 0; right: 0; z-index: 100;
  background: rgba(13,13,21,0.95);
  border-bottom: 1px solid rgba(212,175,55,0.2);
  padding: 12px 16px;
}
.top-bar-inner {
  max-width: 800px; margin: 0 auto;
  display: flex; justify-content: space-between; align-items: center;
  flex-wrap: wrap; gap: 8px;
}
.stats { display: flex; gap: 16px; align-items: center; flex-wrap: wrap; }
.stat { display: flex; gap: 4px; align-items: center; font-size: 14px; }
.top-btns { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
.inv-slot {
  width: 36px; height: 36px;
  background: rgba(30,30,40,0.8);
  border: 1px solid rgba(212,175,55,0.3);
  border-radius: 8px;
  display: flex; align-items: center; justify-content: center;
  font-size: 18px; cursor: pointer;
  transition: transform 0.2s;
}
.inv-slot:hover { transform: scale(1.1); }

.game-card {
  width: 120px; height: 170px;
  border-radius: 10px; padding: 10px;
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  text-align: center; cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
  position: relative; flex-shrink: 0;
}
.game-card:hover:not(.disabled) { transform: translateY(-10px) scale(1.05); box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
.game-card:active:not(.disabled) { transform: scale(0.95); }
.game-card.disabled { opacity: 0.4; cursor: not-allowed; }
.game-card.attack { background: linear-gradient(145deg, #3d1a1a, #1a0808); border: 2px solid #8b0000; }
.game-card.skill { background: linear-gradient(145deg, #1a2a3d, #080810); border: 2px solid #1e4a7a; }
.game-card.power { background: linear-gradient(145deg, #3d3a1a, #1a1808); border: 2px solid #8b7500; }
.game-card.upgraded { box-shadow: 0 0 15px rgba(74, 222, 128, 0.4); }
.game-card.upgraded .card-name { color: #4ade80; }
.card-cost {
  position: absolute; top: -8px; left: -8px;
  width: 32px; height: 32px;
  background: linear-gradient(135deg, #f4d03f, #d4af37);
  border-radius: 50%;
  display: flex; align-items: center; justify-content: center;
  font-weight: bold; font-size: 16px; color: #1a1a1a;
}
.card-icon { font-size: 32px; margin-bottom: 6px; }
.card-name { font-size: 14px; font-weight: 600; color: #f4d03f; margin-bottom: 4px; }
.card-desc { font-size: 12px; color: #aaa; line-height: 1.3; }
.card-upgrade-badge {
  position: absolute; top: -6px; right: -6px;
  background: #22c55e; color: #fff;
  font-size: 10px; font-weight: bold;
  padding: 2px 5px; border-radius: 4px;
}
.game-card.small { width: 80px; height: 110px; }
.game-card.small .card-cost { width: 22px; height: 22px; font-size: 11px; top: -6px; left: -6px; }
.game-card.small .card-icon { font-size: 20px; }
.game-card.small .card-name { font-size: 10px; }
.game-card.small .card-desc { font-size: 8px; }

/* ë± ëª¨ë‹¬ ì „ìš© í° ì¹´ë“œ */
#deckGrid .game-card { width: 160px; height: 220px; }
#deckGrid .card-cost { width: 36px; height: 36px; font-size: 18px; top: -10px; left: -10px; }
#deckGrid .card-icon { font-size: 40px; margin-bottom: 8px; }
#deckGrid .card-name { font-size: 18px; font-weight: 600; margin-bottom: 6px; }
#deckGrid .card-desc { font-size: 14px; line-height: 1.4; }

.enemy-container { display: flex; justify-content: center; gap: 30px; flex-wrap: wrap; }
.enemy-unit { text-align: center; padding: 15px; min-width: 150px; }
.enemy-emoji { font-size: 60px; animation: float 3s ease-in-out infinite; }
.enemy-unit:nth-child(2) .enemy-emoji { animation-delay: 0.5s; }
.enemy-unit:nth-child(3) .enemy-emoji { animation-delay: 1s; }
@keyframes float { 0%,100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
@keyframes shake { 0%,100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
.enemy-emoji.hit { animation: shake 0.3s ease-in-out; }
.enemy-name { font-size: 18px; font-weight: 600; color: #f4d03f; margin: 8px 0; }
.hp-bar { width: 140px; height: 10px; background: #222; border-radius: 5px; margin: 0 auto 6px; overflow: hidden; }
.hp-fill { height: 100%; background: linear-gradient(90deg, #8b0000, #dc143c); transition: width 0.3s; }
.intent { display: inline-block; padding: 6px 12px; background: rgba(20,20,30,0.9); border: 1px solid rgba(212,175,55,0.3); border-radius: 12px; margin-top: 6px; font-size: 13px; }
.status { display: inline-block; padding: 3px 8px; border-radius: 8px; font-size: 11px; margin: 2px; }
.status.block { background: rgba(74,158,255,0.2); color: #4a9eff; }
.status.str { background: rgba(220,20,60,0.2); color: #dc143c; }
.status.vuln { background: rgba(255,165,0,0.2); color: #ffa500; }
.status.weak { background: rgba(100,200,100,0.2); color: #64c864; }
.status.poison { background: rgba(138,43,226,0.2); color: #9f7aea; }
.status.ritual { background: rgba(138,43,226,0.2); color: #c084fc; }

.player-bar {
  background: rgba(20,20,30,0.8);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 12px; padding: 12px 16px; margin: 16px;
  display: flex; justify-content: space-between; align-items: center;
  flex-wrap: wrap; gap: 10px;
}
.energy-orbs { display: flex; gap: 6px; }
.orb {
  width: 30px; height: 30px; border-radius: 50%;
  display: flex; align-items: center; justify-content: center; font-size: 14px;
}
.orb.active { background: linear-gradient(135deg, #ffd700, #ff8c00); box-shadow: 0 0 12px rgba(255,140,0,0.6); }
.orb.empty { background: rgba(30,30,40,0.8); border: 1px solid rgba(255,255,255,0.2); }

.hand { display: flex; justify-content: center; gap: 8px; padding: 16px; flex-wrap: wrap; }

.screen { min-height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 24px; }
.title { font-size: 32px; font-weight: 700; color: #d4af37; margin-bottom: 8px; text-shadow: 0 0 20px rgba(212,175,55,0.5); }
.subtitle { font-size: 16px; color: #888; margin-bottom: 32px; }
.version { font-size: 12px; color: #666; margin-top: 8px; }
.menu-btns { display: flex; flex-direction: column; gap: 12px; width: 100%; max-width: 260px; }

.modal { position: fixed; inset: 0; background: rgba(10,10,15,0.95); z-index: 200; display: flex; align-items: center; justify-content: center; padding: 16px; }
.modal-box { width: 100%; max-width: 500px; max-height: 85vh; overflow-y: auto; background: linear-gradient(145deg, #1a1a24, #0d0d15); border: 1px solid rgba(212,175,55,0.3); border-radius: 16px; padding: 20px; }
.modal-head { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
.modal-title { font-size: 20px; font-weight: 600; color: #d4af37; }
.modal-close { width: 32px; height: 32px; background: rgba(255,255,255,0.1); border: none; border-radius: 50%; color: #888; font-size: 20px; cursor: pointer; }

.save-slot { background: rgba(30,30,40,0.6); border: 1px solid rgba(255,255,255,0.1); border-radius: 10px; padding: 14px; margin-bottom: 10px; }
.save-head { display: flex; justify-content: space-between; margin-bottom: 6px; }
.save-name { font-weight: 600; color: #d4af37; }
.save-date { font-size: 11px; color: #666; }
.save-info { font-size: 13px; color: #888; margin-bottom: 10px; }
.save-btns { display: flex; gap: 8px; }
.save-btns .btn { flex: 1; padding: 10px; font-size: 13px; }

.map-box { background: rgba(20,20,30,0.6); border: 1px solid rgba(212,175,55,0.2); border-radius: 14px; padding: 16px; position: relative; overflow-x: auto; }
.map-container { position: relative; min-height: 540px; width: 100%; }
.map-paths { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0; }
.map-path { stroke: rgba(80,80,100,0.3); stroke-width: 2; fill: none; }
.map-path.accessible { stroke: #d4af37; stroke-width: 3; filter: drop-shadow(0 0 8px rgba(212,175,55,0.9)); animation: pathPulse 1.5s ease-in-out infinite; }
.map-path.visited { stroke: rgba(74,158,255,0.4); stroke-width: 2; }
@keyframes pathPulse { 0%,100% { opacity: 0.6; } 50% { opacity: 1; } }
.map-floor { display: flex; justify-content: space-around; align-items: center; padding: 4px 10px; position: relative; z-index: 1; min-height: 40px; }
.map-floor-label { position: absolute; left: -5px; font-size: 10px; color: #666; }
.map-row { display: flex; justify-content: center; gap: 12px; margin-bottom: 8px; position: relative; }
.map-node {
  width: 44px; height: 44px; border-radius: 50%;
  display: flex; align-items: center; justify-content: center;
  font-size: 20px; transition: all 0.2s; position: relative;
}
.map-node.accessible { background: rgba(212,175,55,0.2); border: 2px solid #d4af37; cursor: pointer; animation: pulse 2s infinite; }
.map-node.accessible:hover { transform: scale(1.15); box-shadow: 0 0 20px rgba(212,175,55,0.5); }
.map-node.visited { background: rgba(40,40,50,0.5); border: 1px solid rgba(255,255,255,0.1); opacity: 0.5; }
.map-node.current { background: rgba(0,200,100,0.3); border: 2px solid #00c864; box-shadow: 0 0 20px rgba(0,200,100,0.4); transform: scale(1.1); }
.map-node.locked { background: rgba(30,30,40,0.3); border: 1px solid rgba(255,255,255,0.05); opacity: 0.3; }
@keyframes pulse { 0%,100% { box-shadow: 0 0 8px rgba(212,175,55,0.4); } 50% { box-shadow: 0 0 18px rgba(212,175,55,0.7); } }
.legend { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; font-size: 11px; color: #888; margin-bottom: 12px; }

.event-box { width: 100%; max-width: 400px; background: linear-gradient(145deg,#1a1a24,#0d0d15); border: 1px solid rgba(138,43,226,0.3); border-radius: 14px; padding: 24px; text-align: center; }
.event-emoji { font-size: 56px; margin-bottom: 12px; }
.event-title { font-size: 22px; font-weight: 600; color: #d4af37; margin-bottom: 6px; }
.event-desc { font-size: 14px; color: #aaa; margin-bottom: 20px; line-height: 1.5; }
.choice-btn { width: 100%; padding: 14px; margin-bottom: 10px; background: rgba(138,43,226,0.15); border: 1px solid rgba(138,43,226,0.4); border-radius: 10px; color: #e8e4d9; font-size: 15px; cursor: pointer; text-align: left; transition: all 0.2s; }
.choice-btn:hover { background: rgba(138,43,226,0.25); transform: translateX(5px); }
.choice-btn:active { transform: scale(0.98); }
.choice-btn:disabled { opacity: 0.5; cursor: not-allowed; }

.quick-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-top: 20px; width: 100%; max-width: 280px; }
.quick-btn { padding: 14px; background: rgba(212,175,55,0.1); border: 1px solid rgba(212,175,55,0.4); border-radius: 10px; color: #d4af37; font-size: 18px; cursor: pointer; transition: all 0.2s; }
.quick-btn:hover { background: rgba(212,175,55,0.2); }
.quick-btn:active { transform: scale(0.96); }

.ai-msg { background: rgba(138,43,226,0.15); border: 1px solid rgba(138,43,226,0.3); border-radius: 10px; padding: 10px 16px; margin: 12px auto; max-width: 400px; text-align: center; }
.ai-msg p { color: #c9a0ff; font-style: italic; font-size: 14px; }
.game-msg { text-align: center; color: #d4af37; font-size: 15px; font-weight: 500; margin: 10px 0; min-height: 24px; }

.shop-section { margin-bottom: 20px; }
.shop-title { font-size: 16px; font-weight: 600; color: #d4af37; margin-bottom: 10px; }
.shop-items { display: flex; gap: 10px; overflow-x: auto; padding-bottom: 8px; }
.shop-item { background: rgba(30,30,40,0.6); border: 1px solid rgba(212,175,55,0.2); border-radius: 10px; padding: 10px; cursor: pointer; flex-shrink: 0; transition: all 0.2s; }
.shop-item:hover { border-color: #d4af37; transform: translateY(-3px); }
.shop-item.sold { opacity: 0.3; pointer-events: none; }
.shop-price { text-align: center; color: #d4af37; font-weight: 600; margin-top: 6px; font-size: 13px; }
.shop-service { background: rgba(30,30,40,0.6); border: 1px solid rgba(212,175,55,0.2); border-radius: 10px; padding: 16px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; transition: all 0.2s; }
.shop-service:hover { border-color: #d4af37; }

.deck-grid { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; padding: 12px 0; }
.deck-filter { display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap; justify-content: center; }
.deck-filter button { padding: 6px 12px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; color: #aaa; font-size: 12px; cursor: pointer; }
.deck-filter button.active { background: rgba(212,175,55,0.2); border-color: #d4af37; color: #d4af37; }

.result-emoji { font-size: 70px; margin-bottom: 12px; }
.result-title { font-size: 32px; font-weight: 700; margin-bottom: 6px; }
.result-title.win { color: #d4af37; }
.result-title.lose { color: #dc143c; }
.result-sub { font-size: 15px; color: #888; margin-bottom: 20px; }
.result-stats { background: rgba(30,30,40,0.6); border: 1px solid rgba(255,255,255,0.1); border-radius: 10px; padding: 16px; margin-bottom: 20px; font-size: 14px; color: #aaa; line-height: 1.8; }

.combat-log { max-height: 80px; overflow-y: auto; background: rgba(0,0,0,0.3); border-radius: 8px; padding: 8px; margin: 8px 16px; font-size: 12px; color: #888; }
.combat-log p { margin: 2px 0; }
.combat-log .dmg { color: #dc143c; }
.combat-log .heal { color: #4ade80; }
.combat-log .block { color: #4a9eff; }

.tooltip { position: fixed; background: rgba(20,20,30,0.95); border: 1px solid rgba(212,175,55,0.4); border-radius: 8px; padding: 12px; max-width: 200px; z-index: 1000; pointer-events: none; }
.tooltip-title { color: #d4af37; font-weight: 600; margin-bottom: 4px; }
.tooltip-desc { color: #aaa; font-size: 12px; line-height: 1.4; }

.target-indicator { position: absolute; top: -20px; left: 50%; transform: translateX(-50%); color: #d4af37; font-size: 20px; animation: bounce 0.5s infinite; }
@keyframes bounce { 0%,100% { transform: translateX(-50%) translateY(0); } 50% { transform: translateX(-50%) translateY(-5px); } }

@media (max-width: 480px) {
  .title { font-size: 26px; }
  .game-card { width: 80px; height: 115px; }
  .game-card .card-icon { font-size: 20px; }
  .game-card .card-name { font-size: 9px; }
  .game-card .card-desc { font-size: 7px; }
  .enemy-emoji { font-size: 45px; }
  .enemy-name { font-size: 14px; }
  .enemy-unit { min-width: 100px; padding: 10px; }
  .hp-bar { width: 100px; }
  .hand { gap: 5px; padding: 10px; }
  .top-bar-inner { font-size: 12px; }
  .stat { font-size: 12px; }
  .inv-slot { width: 30px; height: 30px; font-size: 14px; }
  .map-node { width: 38px; height: 38px; font-size: 16px; }
}
```

  </style>
</head>
<body>
  <div class="top-bar hidden" id="topBar">
    <div class="top-bar-inner">
      <div class="stats">
        <span class="gold">ğŸ”ï¸ <span id="floorNum">1</span>ì¸µ</span>
        <div class="stat"><span class="red">â¤ï¸</span><span id="hpText">80/80</span></div>
        <div class="stat"><span class="gold">ğŸ’°</span><span id="goldText">99</span></div>
      </div>
      <div class="top-btns">
        <div id="potionSlots" style="display:flex;gap:4px;"></div>
        <div id="relicSlots" style="display:flex;gap:4px;"></div>
        <button class="btn btn-dark btn-sm" onclick="showDeck()">ë±</button>
        <button class="btn btn-dark btn-sm" onclick="showMap()">ë§µ</button>
        <button class="btn btn-dark btn-sm" onclick="showSaveMenu()">ğŸ’¾</button>
      </div>
    </div>
  </div>

  <div class="screen" id="menuScreen">
    <div class="title">âš”ï¸ SLAY AI SPIRE âš”ï¸</div>
    <div class="subtitle">ë±ë¹Œë”© ë¡œê·¸ë¼ì´í¬</div>
    <div class="menu-btns">
      <button class="btn btn-gold" onclick="startGame()">ìƒˆ ê²Œì„</button>
      <button class="btn btn-dark hidden" id="continueBtn" onclick="loadAutoSave()">ì´ì–´í•˜ê¸°</button>
      <button class="btn btn-dark" onclick="showSaveMenu()">ì €ì¥ ìŠ¬ë¡¯</button>
    </div>
    <div class="version">v2.0 - ì—…ê·¸ë ˆì´ë“œ & ë°¸ëŸ°ìŠ¤ íŒ¨ì¹˜</div>
  </div>

  <div class="screen hidden" id="mapScreen" style="padding-top:70px;">
    <div class="ai-msg" id="mapAiMsg"><p></p></div>
    <div class="game-msg" id="mapMsg"></div>
    <p class="muted" style="margin-bottom:16px;">ê²½ë¡œë¥¼ ì„ íƒí•˜ì„¸ìš”</p>
    <button class="btn btn-gold" onclick="showMap()">ğŸ—ºï¸ ë§µ ì—´ê¸°</button>
    <div class="quick-grid" id="quickSelect"></div>
  </div>

  <div class="hidden" id="combatScreen" style="padding-top:70px;padding-bottom:20px;">
    <div class="ai-msg" id="combatAiMsg"><p></p></div>
    <div class="enemy-container" id="enemyContainer"></div>
    <div class="combat-log" id="combatLog"></div>
    <div class="game-msg" id="combatMsg"></div>
    <div class="player-bar">
      <div class="stats" style="flex-wrap:wrap;">
        <div class="stat"><span class="red">â¤ï¸</span><span id="playerHp">80/80</span></div>
        <div class="stat" id="playerBlock" style="display:none;"><span class="blue">ğŸ›¡ï¸</span><span></span></div>
        <span id="playerStr" class="status str" style="display:none;"></span>
        <span id="playerDex" class="status block" style="display:none;"></span>
        <span id="playerWeak" class="status weak" style="display:none;"></span>
        <span id="playerVuln" class="status vuln" style="display:none;"></span>
        <span id="playerPoison" class="status poison" style="display:none;"></span>
      </div>
      <div class="energy-orbs" id="energyOrbs"></div>
    </div>
    <div class="muted center" style="font-size:12px;">ë½‘ê¸°: <span id="drawCount">0</span> | ë²„ë¦¼: <span id="discardCount">0</span> | ì†Œë©¸: <span id="exhaustCount">0</span></div>
    <div class="hand" id="handArea"></div>
    <div class="center" style="margin-top:12px;">
      <button class="btn btn-gold" id="endTurnBtn" onclick="endTurn()">í„´ ì¢…ë£Œ</button>
    </div>
  </div>

  <div class="screen hidden" id="rewardScreen" style="padding-top:70px;">
    <div class="event-box">
      <div class="event-emoji">ğŸ‰</div>
      <div class="event-title">ìŠ¹ë¦¬!</div>
      <div id="rewardContent"></div>
    </div>
  </div>

  <div class="screen hidden" id="eventScreen" style="padding-top:70px;">
    <div class="event-box" id="eventBox"></div>
  </div>

  <div class="screen hidden" id="restScreen" style="padding-top:70px;">
    <div class="event-box" id="restBox"></div>
  </div>

  <div class="hidden" id="shopScreen" style="padding:70px 16px 24px;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">
      <h2 class="gold" style="font-size:22px;">ğŸ›’ ìƒì </h2>
      <span class="gold" style="font-size:18px;">ğŸ’° <span id="shopGold">0</span></span>
    </div>
    <div class="ai-msg" id="shopAiMsg"><p></p></div>
    <div class="game-msg" id="shopMsg"></div>
    <div id="shopContent"></div>
    <button class="btn btn-dark" style="margin-top:16px;" onclick="exitShop()">ë‚˜ê°€ê¸°</button>
  </div>

  <div class="screen hidden" id="victoryScreen">
    <div class="result-emoji">ğŸ†</div>
    <div class="result-title win">ìŠ¹ë¦¬!</div>
    <div class="result-sub">ì²¨íƒ‘ì„ ì •ë³µí•˜ì˜€ìŠµë‹ˆë‹¤</div>
    <div class="result-stats" id="victoryStats"></div>
    <button class="btn btn-gold" onclick="goToMenu()">ë‹¤ì‹œ ë„ì „</button>
  </div>

  <div class="screen hidden" id="defeatScreen">
    <div class="result-emoji">ğŸ’€</div>
    <div class="result-title lose">íŒ¨ë°°</div>
    <div class="result-sub" id="defeatSub"></div>
    <div class="result-stats" id="defeatStats"></div>
    <button class="btn btn-dark" onclick="goToMenu()">ë‹¤ì‹œ ë„ì „</button>
  </div>

  <div class="modal hidden" id="saveModal">
    <div class="modal-box">
      <div class="modal-head">
        <div class="modal-title">ğŸ’¾ ì €ì¥ / ë¶ˆëŸ¬ì˜¤ê¸°</div>
        <button class="modal-close" onclick="closeSaveMenu()">Ã—</button>
      </div>
      <div id="saveMsg" class="center gold" style="margin-bottom:12px;"></div>
      <div id="saveSlots"></div>
    </div>
  </div>

  <div class="modal hidden" id="deckModal">
    <div class="modal-box" style="max-width:800px;">
      <div class="modal-head">
        <div class="modal-title">ğŸ“š ë± (<span id="deckCount">0</span>ì¥)</div>
        <button class="modal-close" onclick="closeDeck()">Ã—</button>
      </div>
      <div class="deck-filter" id="deckFilter"></div>
      <div class="deck-grid" id="deckGrid"></div>
    </div>
  </div>

  <div class="modal hidden" id="mapModal">
    <div class="modal-box" style="max-width:480px;">
      <div class="modal-head">
        <div class="modal-title">ğŸ—ºï¸ ë§µ</div>
        <button class="modal-close" onclick="closeMap()">Ã—</button>
      </div>
      <div class="legend" id="mapLegend"></div>
      <div class="map-box" id="mapBox"></div>
    </div>
  </div>

  <div class="modal hidden" id="upgradeModal">
    <div class="modal-box">
      <div class="modal-head">
        <div class="modal-title">â¬†ï¸ ì¹´ë“œ ì—…ê·¸ë ˆì´ë“œ</div>
        <button class="modal-close" onclick="closeUpgrade()">Ã—</button>
      </div>
      <p class="muted center" style="margin-bottom:16px;">ì—…ê·¸ë ˆì´ë“œí•  ì¹´ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”</p>
      <div class="deck-grid" id="upgradeGrid"></div>
    </div>
  </div>

  <div class="modal hidden" id="removeModal">
    <div class="modal-box">
      <div class="modal-head">
        <div class="modal-title">ğŸ—‘ï¸ ì¹´ë“œ ì œê±°</div>
        <button class="modal-close" onclick="closeRemove()">Ã—</button>
      </div>
      <p class="muted center" style="margin-bottom:16px;">ì œê±°í•  ì¹´ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”</p>
      <div class="deck-grid" id="removeGrid"></div>
    </div>
  </div>

  <div id="tooltip" class="tooltip hidden"></div>

  <script>
    // ========== ì¹´ë“œ ë°ì´í„° (ì—…ê·¸ë ˆì´ë“œ í¬í•¨) ==========
    const CARDS = {
      // ê¸°ë³¸ ì¹´ë“œ
      strike: { name: 'íƒ€ê²©', cost: 1, type: 'attack', damage: 6, desc: '6 ë°ë¯¸ì§€', upgradedName: 'íƒ€ê²©+', upgradedDamage: 9, upgradedDesc: '9 ë°ë¯¸ì§€' },
      defend: { name: 'ìˆ˜ë¹„', cost: 1, type: 'skill', block: 5, desc: '5 ë°©ì–´ë„', upgradedName: 'ìˆ˜ë¹„+', upgradedBlock: 8, upgradedDesc: '8 ë°©ì–´ë„' },
      bash: { name: 'ê°•íƒ€', cost: 2, type: 'attack', damage: 8, vulnerable: 2, desc: '8 ë€, ì·¨ì•½2', upgradedName: 'ê°•íƒ€+', upgradedDamage: 10, upgradedVulnerable: 3, upgradedDesc: '10 ë€, ì·¨ì•½3' },
      // ê³µê²© ì¹´ë“œ
      cleave: { name: 'ê°€ë¥´ê¸°', cost: 1, type: 'attack', damage: 8, aoe: true, desc: 'ì „ì²´ 8 ë°ë¯¸ì§€', upgradedName: 'ê°€ë¥´ê¸°+', upgradedDamage: 11, upgradedDesc: 'ì „ì²´ 11 ë°ë¯¸ì§€' },
      ironWave: { name: 'ì² ë²½íŒŒë™', cost: 1, type: 'attack', damage: 5, block: 5, desc: '5 ë°©ì–´, 5 ë€', upgradedName: 'ì² ë²½íŒŒë™+', upgradedDamage: 7, upgradedBlock: 7, upgradedDesc: '7 ë°©ì–´, 7 ë€' },
      pommel: { name: 'ì†ì¡ì´', cost: 1, type: 'attack', damage: 9, draw: 1, desc: '9 ë€, 1ë“œë¡œìš°', upgradedName: 'ì†ì¡ì´+', upgradedDamage: 10, upgradedDraw: 2, upgradedDesc: '10 ë€, 2ë“œë¡œìš°' },
      anger: { name: 'ë¶„ë…¸', cost: 0, type: 'attack', damage: 6, addCopy: true, desc: '6 ë€, ë³µì‚¬ë³¸ ì¶”ê°€', upgradedName: 'ë¶„ë…¸+', upgradedDamage: 8, upgradedDesc: '8 ë€, ë³µì‚¬ë³¸ ì¶”ê°€' },
      carnage: { name: 'ëŒ€í•™ì‚´', cost: 2, type: 'attack', damage: 20, exhaust: true, desc: '20 ë€, ì†Œë©¸', upgradedName: 'ëŒ€í•™ì‚´+', upgradedDamage: 28, upgradedDesc: '28 ë€, ì†Œë©¸' },
      heavyBlade: { name: 'í—¤ë¹„ë¸”ë ˆì´ë“œ', cost: 2, type: 'attack', damage: 14, strMult: 3, desc: '14 ë€ (í˜x3)', upgradedName: 'í—¤ë¹„ë¸”ë ˆì´ë“œ+', upgradedDamage: 14, upgradedStrMult: 5, upgradedDesc: '14 ë€ (í˜x5)' },
      twinStrike: { name: 'ìŒë‘¥ì´íƒ€ê²©', cost: 1, type: 'attack', damage: 5, times: 2, desc: '5 ë€ x2', upgradedName: 'ìŒë‘¥ì´íƒ€ê²©+', upgradedDamage: 7, upgradedDesc: '7 ë€ x2' },
      bodySlam: { name: 'ëª¸í†µë°•ì¹˜ê¸°', cost: 1, type: 'attack', blockDamage: true, desc: 'ë°©ì–´ë„ë§Œí¼ ë€', upgradedName: 'ëª¸í†µë°•ì¹˜ê¸°+', upgradedCost: 0, upgradedDesc: 'ë°©ì–´ë„ë§Œí¼ ë€' },
      clothesline: { name: 'ë¹¨ë«ì¤„', cost: 2, type: 'attack', damage: 12, weak: 2, desc: '12 ë€, ì•½í™”2', upgradedName: 'ë¹¨ë«ì¤„+', upgradedDamage: 14, upgradedWeak: 3, upgradedDesc: '14 ë€, ì•½í™”3' },
      // ìŠ¤í‚¬ ì¹´ë“œ
      shrug: { name: 'ë–¨ì³ë‚´ê¸°', cost: 1, type: 'skill', block: 8, draw: 1, desc: '8 ë°©ì–´, 1ë“œë¡œìš°', upgradedName: 'ë–¨ì³ë‚´ê¸°+', upgradedBlock: 11, upgradedDesc: '11 ë°©ì–´, 1ë“œë¡œìš°' },
      armaments: { name: 'ë¬´ì¥', cost: 1, type: 'skill', block: 5, upgradeHand: true, desc: '5 ë°©ì–´, ì†íŒ¨ 1ì¥ ì—…ê¸€', upgradedName: 'ë¬´ì¥+', upgradedBlock: 5, upgradedUpgradeAll: true, upgradedDesc: '5 ë°©ì–´, ì†íŒ¨ ì „ë¶€ ì—…ê¸€' },
      shroud: { name: 'ì€í', cost: 1, type: 'skill', block: 6, exhaust: true, desc: '6 ë°©ì–´, ì†Œë©¸', upgradedName: 'ì€í+', upgradedBlock: 10, upgradedDesc: '10 ë°©ì–´, ì†Œë©¸' },
      truGrit: { name: 'ì§„ì •í•œ íˆ¬ì§€', cost: 1, type: 'skill', block: 7, exhaustRandom: true, desc: '7 ë°©ì–´, ì†íŒ¨ 1ì¥ ì†Œë©¸', upgradedName: 'ì§„ì •í•œ íˆ¬ì§€+', upgradedBlock: 9, upgradedExhaustChoice: true, upgradedDesc: '9 ë°©ì–´, ì„ íƒ ì†Œë©¸' },
      battleTrance: { name: 'ì „íˆ¬ ë¬´ì•„ì§€ê²½', cost: 0, type: 'skill', draw: 3, cantDraw: true, desc: '3 ë“œë¡œìš°, ì´ë²ˆí„´ ì¶”ê°€ ë“œë¡œìš° ë¶ˆê°€', upgradedName: 'ì „íˆ¬ ë¬´ì•„ì§€ê²½+', upgradedDraw: 4, upgradedDesc: '4 ë“œë¡œìš°, ì´ë²ˆí„´ ì¶”ê°€ ë“œë¡œìš° ë¶ˆê°€' },
      bloodletting: { name: 'ì‚¬í˜ˆ', cost: 0, type: 'skill', selfDamage: 3, gainEnergy: 2, desc: 'HP -3, ì—ë„ˆì§€ +2', upgradedName: 'ì‚¬í˜ˆ+', upgradedGainEnergy: 3, upgradedDesc: 'HP -3, ì—ë„ˆì§€ +3' },
      // íŒŒì›Œ ì¹´ë“œ
      inflame: { name: 'ì í™”', cost: 1, type: 'power', strength: 2, desc: 'í˜ +2', upgradedName: 'ì í™”+', upgradedStrength: 3, upgradedDesc: 'í˜ +3' },
      metal: { name: 'ê¸ˆì†í™”', cost: 1, type: 'power', endBlock: 3, desc: 'í„´ë§ˆë‹¤ 3 ë°©ì–´', upgradedName: 'ê¸ˆì†í™”+', upgradedEndBlock: 4, upgradedDesc: 'í„´ë§ˆë‹¤ 4 ë°©ì–´' },
      demon: { name: 'ì•…ë§ˆí˜•ìƒ', cost: 3, type: 'power', strPerTurn: 2, desc: 'í„´ë§ˆë‹¤ í˜+2', upgradedName: 'ì•…ë§ˆí˜•ìƒ+', upgradedStrPerTurn: 3, upgradedDesc: 'í„´ë§ˆë‹¤ í˜+3' },
      rage: { name: 'ë¶„ë…¸', cost: 0, type: 'power', blockOnAttack: 3, desc: 'ê³µê²©ì‹œ 3 ë°©ì–´', upgradedName: 'ë¶„ë…¸+', upgradedBlockOnAttack: 5, upgradedDesc: 'ê³µê²©ì‹œ 5 ë°©ì–´' },
      juggernaut: { name: 'ì €ê±°ë„ˆíŠ¸', cost: 2, type: 'power', damageOnBlock: 5, desc: 'ë°©ì–´ë„ íšë“ì‹œ 5 ë€', upgradedName: 'ì €ê±°ë„ˆíŠ¸+', upgradedDamageOnBlock: 7, upgradedDesc: 'ë°©ì–´ë„ íšë“ì‹œ 7 ë€' },
    };

    // ========== ì  ë°ì´í„° ==========
    const ENEMIES = {
      // Act 1 ì¼ë°˜
      cultist: { name: 'ê´‘ì‹ ë„', hp: [48, 54], emoji: 'ğŸ§™â€â™‚ï¸', atks: [{ dmg: 6, name: 'ì˜ì‹ ì¹¼ë‚ ' }, { ritual: 3, name: 'ì˜ì‹' }] },
      jawWorm: { name: 'í„± ë²Œë ˆ', hp: [40, 44], emoji: 'ğŸ›', atks: [{ dmg: 11, name: 'ë¬¼ê¸°' }, { block: 6, str: 4, name: 'ì›…í¬ë¦¬ê¸°' }, { dmg: 7, name: 'ëŒì§„' }] },
      slimeS: { name: 'ì‘ì€ ìŠ¬ë¼ì„', hp: [12, 16], emoji: 'ğŸŸ¢', atks: [{ dmg: 5, name: 'ì°°ì‹¹' }] },
      slimeM: { name: 'ìŠ¬ë¼ì„', hp: [28, 32], emoji: 'ğŸŸ¡', atks: [{ dmg: 8, name: 'ì°°ì‹¹' }, { dmg: 10, weak: 1, name: 'í•¥ê¸°' }] },
      looter: { name: 'ì•½íƒˆì', hp: [44, 48], emoji: 'ğŸ¦¹', atks: [{ dmg: 10, name: 'í€ì¹˜' }, { dmg: 12, name: 'ìŠ¬ë˜ì‹œ' }, { escape: true, name: 'ë„ì£¼' }] },
      // Act 1 ì—˜ë¦¬íŠ¸
      gremlinNob: { name: 'ê·¸ë ˜ë¦° ëŒ€ì¥', hp: [82, 86], emoji: 'ğŸ‘º', elite: true, atks: [{ dmg: 14, name: 'ëŒì§„' }, { dmg: 16, name: 'í•´ê³¨ ë¶€ìˆ˜ê¸°' }, { str: 2, name: 'ë¶„ë…¸' }] },
      lagavulin: { name: 'ë¼ê°€ë¶ˆë¦°', hp: [110, 115], emoji: 'ğŸ˜ˆ', elite: true, sleeping: true, atks: [{ dmg: 18, name: 'ê³µê²©' }, { debuff: true, strDown: 1, dexDown: 1, name: 'ì‚¬ì´í€ ì†Œìš¸' }] },
      sentries: { name: 'íŒŒìˆ˜ê¾¼', hp: [38, 42], emoji: 'ğŸ¤–', elite: true, count: 3, atks: [{ dmg: 9, name: 'ë ˆì´ì €' }, { status: 'dazed', name: 'í˜¼ë€' }] },
      // Act 1 ë³´ìŠ¤
      slimeBoss: { name: 'ìŠ¬ë¼ì„ ë³´ìŠ¤', hp: [140, 150], emoji: 'ğŸŸ©', boss: true, atks: [{ dmg: 35, name: 'ìŠ¬ë¨' }, { split: true, name: 'ë¶„ì—´' }] },
      guardian: { name: 'ìˆ˜í˜¸ì', hp: [240, 250], emoji: 'ğŸ¤–', boss: true, atks: [{ dmg: 5, times: 4, name: 'ì² ë²½ ë‚œíƒ€' }, { dmg: 32, name: 'ê²©ë ¬í•œ ê³µê²©' }, { block: 9, dmg: 8, name: 'ì¶©ì „ ë°©íŒ¨' }] },
      hexaghost: { name: 'í—¥ì‚¬ê³ ìŠ¤íŠ¸', hp: [250, 260], emoji: 'ğŸ‘»', boss: true, atks: [{ dmg: 2, times: 6, name: 'í™œì„±í™”' }, { dmg: 6, times: 6, name: 'ë¶„ë…¸' }, { dmg: 45, name: 'ì§€ì˜¥ë¶ˆ' }] },
    };

    // ========== ë ë¦­ ë°ì´í„° ==========
    const RELICS = {
      blood: { name: 'ë¶ˆíƒ€ëŠ” í”¼', emoji: 'ğŸ©¸', desc: 'ì „íˆ¬ í›„ HP 6 íšŒë³µ', heal: 6 },
      anchor: { name: 'ë‹»', emoji: 'âš“', desc: 'ì „íˆ¬ ì‹œì‘ì‹œ ë°©ì–´ë„ 10', startBlock: 10 },
      vajra: { name: 'ê¸ˆê°•ì €', emoji: 'ğŸ’', desc: 'ì „íˆ¬ ì‹œì‘ì‹œ í˜ +1', startStr: 1 },
      lantern: { name: 'ë“±ë¶ˆ', emoji: 'ğŸ®', desc: 'ì „íˆ¬ ì²« í„´ ì—ë„ˆì§€ +1', firstTurnEnergy: 1 },
      oddMushroom: { name: 'ì´ìƒí•œ ë²„ì„¯', emoji: 'ğŸ„', desc: 'ì ì—ê²Œ ì·¨ì•½ 1 ë¶€ì—¬', startVuln: 1 },
      bagOfMarbles: { name: 'êµ¬ìŠ¬ ì£¼ë¨¸ë‹ˆ', emoji: 'ğŸ”®', desc: 'ì „íˆ¬ ì‹œì‘ì‹œ ì  ì „ì²´ ì·¨ì•½ 1', startVulnAll: 1 },
      redSkull: { name: 'ë¶‰ì€ í•´ê³¨', emoji: 'ğŸ’€', desc: 'HP 50% ì´í•˜ì‹œ í˜ +3', lowHpStr: 3 },
      penNib: { name: 'íœì´‰', emoji: 'âœ’ï¸', desc: '10ë²ˆì§¸ ê³µê²© 2ë°° ë°ë¯¸ì§€', attackCount: 0, doubleEvery: 10 },
      happyFlower: { name: 'í–‰ë³µí•œ ê½ƒ', emoji: 'ğŸŒ¸', desc: '3í„´ë§ˆë‹¤ ì—ë„ˆì§€ +1', turnCount: 0, energyEvery: 3 },
      meatOnBone: { name: 'ë¼ˆì— ë¶™ì€ ê³ ê¸°', emoji: 'ğŸ–', desc: 'ì „íˆ¬ ì¢…ë£Œì‹œ HP 50% ì´í•˜ë©´ 12 íšŒë³µ', lowHpHeal: 12 },
      torii: { name: 'í† ë¦¬ì´', emoji: 'â›©ï¸', desc: '5 ì´í•˜ ë°ë¯¸ì§€ë¥¼ 1ë¡œ ê°ì†Œ', reduceLowDmg: true },
      paperFrog: { name: 'ì¢…ì´ ê°œêµ¬ë¦¬', emoji: 'ğŸ¸', desc: 'ì·¨ì•½ ì ì—ê²Œ +75% ë€ (ê¸°ë³¸ 50%)', vulnBonus: 0.25 },
      orichalcum: { name: 'ì˜¤ë¦¬í•˜ë¥´ì½˜', emoji: 'ğŸ›¡ï¸', desc: 'í„´ ì¢…ë£Œì‹œ ë°©ì–´ 0ì´ë©´ 6 ë°©ì–´', noBlockGain: 6 },
    };

    // ========== í¬ì…˜ ë°ì´í„° ==========
    const POTIONS = {
      fire: { name: 'í™”ì—¼ í¬ì…˜', emoji: 'ğŸ”¥', desc: 'ì  í•˜ë‚˜ì—ê²Œ 20 ë°ë¯¸ì§€', dmg: 20 },
      block: { name: 'ë°©ì–´ í¬ì…˜', emoji: 'ğŸ›¡ï¸', desc: 'ë°©ì–´ë„ 12 íšë“', block: 12 },
      health: { name: 'ê³¼ì¼ ì£¼ìŠ¤', emoji: 'ğŸ§ƒ', desc: 'ì²´ë ¥ 20% íšŒë³µ', healPct: 0.2 },
      str: { name: 'í˜ í¬ì…˜', emoji: 'ğŸ’ª', desc: 'ì´ë²ˆ ì „íˆ¬ í˜ +2', str: 2 },
      speed: { name: 'ì†ë„ í¬ì…˜', emoji: 'ğŸ’¨', desc: 'ì´ë²ˆ í„´ ë¯¼ì²© +5', dex: 5 },
      weak: { name: 'ê³µí¬ í¬ì…˜', emoji: 'ğŸ˜±', desc: 'ì  ì „ì²´ì— ì•½í™” 3', weakAll: 3 },
      poison: { name: 'ë… í¬ì…˜', emoji: 'â˜ ï¸', desc: 'ì  í•˜ë‚˜ì— ë… 6', poison: 6 },
      ancient: { name: 'ê³ ëŒ€ í¬ì…˜', emoji: 'ğŸº', desc: 'ëœë¤ íŒŒì›Œ 1ê°œ íšë“', randomPower: true },
      energy: { name: 'ì—ë„ˆì§€ í¬ì…˜', emoji: 'âš¡', desc: 'ì—ë„ˆì§€ +2', energy: 2 },
    };

    // ========== ì´ë²¤íŠ¸ ë°ì´í„° ==========
    const EVENTS = [
      {
        id: 'bigFish', title: 'í° ë¬¼ê³ ê¸°', emoji: 'ğŸŸ',
        desc: 'ê±°ëŒ€í•œ í™©ê¸ˆë¹› ë¬¼ê³ ê¸°ê°€ ë¬¼ ìœ„ë¡œ ì†Ÿì•„ì˜¬ëìŠµë‹ˆë‹¤.',
        choices: [
          { text: 'ğŸ– ë°”ë‚˜ë‚˜ ë¨¹ê¸° (HP 33% íšŒë³µ)', healPct: 0.33 },
          { text: 'ğŸŸ ë„ë„› ë¨¹ê¸° (ìµœëŒ€HP +5)', maxHp: 5 },
          { text: 'ğŸ“¦ ìƒì ì—´ê¸° (ë ë¦­ íšë“, HP -10)', relic: true, damage: 10 }
        ]
      },
      {
        id: 'goldenIdol', title: 'í™©ê¸ˆ ìš°ìƒ', emoji: 'ğŸ—¿',
        desc: 'í™©ê¸ˆ ìš°ìƒì´ ì œë‹¨ ìœ„ì—ì„œ ë¹›ë‚˜ê³  ìˆìŠµë‹ˆë‹¤.',
        choices: [
          { text: 'ğŸ’° ê°€ì ¸ê°„ë‹¤ (ê¸ˆí™” +250, ì €ì£¼ íšë“)', gold: 250, curse: true },
          { text: 'ğŸš¶ ì§€ë‚˜ê°„ë‹¤' }
        ]
      },
      {
        id: 'neow', title: 'ì‹ ë¹„ë¡œìš´ ì¡´ì¬', emoji: 'ğŸ‘ï¸',
        desc: 'ê¸°ì´í•œ ì¡´ì¬ê°€ ì„ íƒì„ ì œì•ˆí•©ë‹ˆë‹¤.',
        choices: [
          { text: 'ğŸ’ª í˜ì„ ì›í•œë‹¤ (í˜ ë ë¦­ íšë“)', relicKey: 'vajra' },
          { text: 'â¤ï¸ ìƒëª…ì„ ì›í•œë‹¤ (ìµœëŒ€HP +8)', maxHp: 8 },
          { text: 'ğŸ’° ë¶€ë¥¼ ì›í•œë‹¤ (ê¸ˆí™” +100)', gold: 100 }
        ]
      },
      {
        id: 'shrine', title: 'ìŠí˜€ì§„ ì‹ ì „', emoji: 'â›ª',
        desc: 'ê³ ëŒ€ì˜ ì‹ ì „ì´ ë‹¹ì‹ ì„ ë¶€ë¦…ë‹ˆë‹¤.',
        choices: [
          { text: 'ğŸ™ ê¸°ë„í•œë‹¤ (ì¹´ë“œ ì—…ê·¸ë ˆì´ë“œ)', upgradeRandom: true },
          { text: 'ğŸ”¥ ë¶ˆíƒœìš´ë‹¤ (ì¹´ë“œ ì œê±°)', removeRandom: true },
          { text: 'ğŸš¶ ì§€ë‚˜ê°„ë‹¤' }
        ]
      },
      {
        id: 'treasure', title: 'ë³´ë¬¼ìƒì', emoji: 'ğŸ“¦',
        desc: 'ë¨¼ì§€ ìŒ“ì¸ ë³´ë¬¼ìƒìê°€ ìˆìŠµë‹ˆë‹¤.',
        choices: [
          { text: 'ğŸ“¦ ì—°ë‹¤ (ë ë¦­ íšë“)', relic: true },
          { text: 'ğŸ’° ë¶€ìˆœë‹¤ (ê¸ˆí™” +50)', gold: 50 }
        ]
      },
      {
        id: 'vampire', title: 'ë±€íŒŒì´ì–´', emoji: 'ğŸ§›',
        desc: 'ë±€íŒŒì´ì–´ê°€ ê±°ë˜ë¥¼ ì œì•ˆí•©ë‹ˆë‹¤.',
        choices: [
          { text: 'ğŸ©¸ í”¼ë¥¼ ì¤€ë‹¤ (ìµœëŒ€HP -5, í¬ê·€ ë ë¦­)', maxHpLoss: 5, rareRelic: true },
          { text: 'âš”ï¸ ì‹¸ìš´ë‹¤ (ì—˜ë¦¬íŠ¸ ì „íˆ¬)', combat: 'elite' },
          { text: 'ğŸš¶ ê±°ì ˆí•œë‹¤' }
        ]
      },
      {
        id: 'wheelOfChange', title: 'ìš´ëª…ì˜ ìˆ˜ë ˆë°”í€´', emoji: 'ğŸ¡',
        desc: 'ê±°ëŒ€í•œ ìˆ˜ë ˆë°”í€´ê°€ ëŒì•„ê°‘ë‹ˆë‹¤.',
        choices: [
          { text: 'ğŸ° ëŒë¦°ë‹¤ (ëœë¤ íš¨ê³¼)', randomWheel: true }
        ]
      }
    ];

    const NODE_ICONS = { start: 'ğŸ ', enemy: 'ğŸ‘¹', elite: 'ğŸ’€', boss: 'ğŸ‘‘', event: 'â“', rest: 'ğŸ”¥', shop: 'ğŸ›’', treasure: 'ğŸ’' };
    const NODE_NAMES = { start: 'ì‹œì‘', enemy: 'ì ', elite: 'ì—˜ë¦¬íŠ¸', boss: 'ë³´ìŠ¤', event: 'ì´ë²¤íŠ¸', rest: 'íœ´ì‹', shop: 'ìƒì ', treasure: 'ë³´ë¬¼' };

    // ========== ê²Œì„ ìƒíƒœ ==========
    let state = 'menu', floor = 1, gold = 99;
    let hp = 80, maxHp = 80, block = 0, energy = 3, maxEnergy = 3;
    let strength = 0, dexterity = 0, weak = 0, vulnerable = 0, poison = 0;
    let deck = [], hand = [], drawPile = [], discardPile = [], exhaustPile = [];
    let relics = [], potions = [];
    let enemies = [], turn = 1, powers = {};
    let mapNodes = [], currentNode = null, visitedNodes = [];
    let animating = false, aiMsg = '', gameMsg = '';
    let currentEvent = null, shopItems = null;
    let rewardGold = 0, rewardCards = [], rewardPotion = null, rewardRelic = null;
    let combatLogs = [], selectedCardIndex = -1, targetMode = false;
    let cantDrawThisTurn = false, firstTurn = true;
    let attackCounter = 0;

    // ========== ìœ í‹¸ ==========
    const $ = id => document.getElementById(id);
    const rand = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;
    const shuffle = arr => [...arr].sort(() => Math.random() - 0.5);
    const uid = () => Date.now() + '-' + Math.random().toString(36).slice(2, 7);
    const createCard = (key, upgraded = false) => {
      const base = CARDS[key];
      const card = { ...base, key, uid: uid(), upgraded };
      if (upgraded) {
        if (base.upgradedName) card.name = base.upgradedName;
        if (base.upgradedCost !== undefined) card.cost = base.upgradedCost;
        if (base.upgradedDamage !== undefined) card.damage = base.upgradedDamage;
        if (base.upgradedBlock !== undefined) card.block = base.upgradedBlock;
        if (base.upgradedDraw !== undefined) card.draw = base.upgradedDraw;
        if (base.upgradedDesc) card.desc = base.upgradedDesc;
        if (base.upgradedStrength !== undefined) card.strength = base.upgradedStrength;
        if (base.upgradedEndBlock !== undefined) card.endBlock = base.upgradedEndBlock;
        if (base.upgradedStrPerTurn !== undefined) card.strPerTurn = base.upgradedStrPerTurn;
        if (base.upgradedVulnerable !== undefined) card.vulnerable = base.upgradedVulnerable;
        if (base.upgradedWeak !== undefined) card.weak = base.upgradedWeak;
        if (base.upgradedStrMult !== undefined) card.strMult = base.upgradedStrMult;
        if (base.upgradedGainEnergy !== undefined) card.gainEnergy = base.upgradedGainEnergy;
        if (base.upgradedBlockOnAttack !== undefined) card.blockOnAttack = base.upgradedBlockOnAttack;
        if (base.upgradedDamageOnBlock !== undefined) card.damageOnBlock = base.upgradedDamageOnBlock;
        if (base.upgradedUpgradeAll) card.upgradeAll = true;
      }
      return card;
    };

    function upgradeCard(card) {
      if (card.upgraded) return card;
      const base = CARDS[card.key];
      card.upgraded = true;
      if (base.upgradedName) card.name = base.upgradedName;
      if (base.upgradedCost !== undefined) card.cost = base.upgradedCost;
      if (base.upgradedDamage !== undefined) card.damage = base.upgradedDamage;
      if (base.upgradedBlock !== undefined) card.block = base.upgradedBlock;
      if (base.upgradedDraw !== undefined) card.draw = base.upgradedDraw;
      if (base.upgradedDesc) card.desc = base.upgradedDesc;
      if (base.upgradedStrength !== undefined) card.strength = base.upgradedStrength;
      if (base.upgradedEndBlock !== undefined) card.endBlock = base.upgradedEndBlock;
      if (base.upgradedStrPerTurn !== undefined) card.strPerTurn = base.upgradedStrPerTurn;
      if (base.upgradedVulnerable !== undefined) card.vulnerable = base.upgradedVulnerable;
      if (base.upgradedWeak !== undefined) card.weak = base.upgradedWeak;
      if (base.upgradedStrMult !== undefined) card.strMult = base.upgradedStrMult;
      if (base.upgradedGainEnergy !== undefined) card.gainEnergy = base.upgradedGainEnergy;
      if (base.upgradedBlockOnAttack !== undefined) card.blockOnAttack = base.upgradedBlockOnAttack;
      if (base.upgradedDamageOnBlock !== undefined) card.damageOnBlock = base.upgradedDamageOnBlock;
      if (base.upgradedUpgradeAll) card.upgradeAll = true;
      return card;
    }

    function addCombatLog(msg, type = '') {
      combatLogs.push({ msg, type });
      if (combatLogs.length > 20) combatLogs.shift();
    }

    // ========== ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° ==========
    const getSaveData = () => ({
      floor, gold, hp, maxHp, block, energy, maxEnergy, strength, dexterity, weak, vulnerable, poison,
      deck, hand, drawPile, discardPile, exhaustPile, relics, potions,
      enemies, turn, powers, mapNodes, currentNode, visitedNodes, state,
      currentEvent, shopItems, rewardGold, rewardCards, rewardPotion, rewardRelic,
      attackCounter,
      savedAt: new Date().toLocaleString('ko-KR')
    });

    const loadSaveData = (d) => {
      floor = d.floor; gold = d.gold; hp = d.hp; maxHp = d.maxHp; block = d.block || 0;
      energy = d.energy; maxEnergy = d.maxEnergy; strength = d.strength || 0;
      dexterity = d.dexterity || 0; weak = d.weak || 0; vulnerable = d.vulnerable || 0;
      poison = d.poison || 0;
      deck = d.deck || []; hand = d.hand || []; drawPile = d.drawPile || [];
      discardPile = d.discardPile || []; exhaustPile = d.exhaustPile || [];
      relics = d.relics || []; potions = d.potions || [];
      enemies = d.enemies || []; turn = d.turn || 1; powers = d.powers || {};
      mapNodes = d.mapNodes || []; currentNode = d.currentNode; visitedNodes = d.visitedNodes || [];
      state = d.state || 'map';
      currentEvent = d.currentEvent || null;
      shopItems = d.shopItems || null;
      rewardGold = d.rewardGold || 0;
      rewardCards = d.rewardCards || [];
      rewardPotion = d.rewardPotion || null;
      rewardRelic = d.rewardRelic || null;
      attackCounter = d.attackCounter || 0;
    };

    const save = (i) => {
      const d = getSaveData();
      localStorage.setItem('slayv2-' + i, JSON.stringify(d));
      $('saveMsg').textContent = 'ì €ì¥ ì™„ë£Œ!';
      setTimeout(() => $('saveMsg').textContent = '', 2000);
      renderSaveSlots();
    };

    const load = (i) => {
      const raw = localStorage.getItem('slayv2-' + i);
      if (!raw) return;
      loadSaveData(JSON.parse(raw));
      closeSaveMenu();
      aiMsg = 'ëª¨í—˜ì„ ê³„ì†í•©ë‹ˆë‹¤...';
      render();
    };

    const autoSave = () => {
      const d = getSaveData();
      d.savedAt += ' (ìë™)';
      localStorage.setItem('slayv2-auto', JSON.stringify(d));
    };

    const loadAutoSave = () => {
      const raw = localStorage.getItem('slayv2-auto');
      if (!raw) return;
      loadSaveData(JSON.parse(raw));
      aiMsg = 'ì´ì „ ëª¨í—˜ì„ ì´ì–´ê°‘ë‹ˆë‹¤...';
      render();
    };

    const delSave = (i) => { localStorage.removeItem('slayv2-' + i); renderSaveSlots(); };

    // ========== ë Œë”ë§ ==========
    function render() {
      ['menuScreen', 'mapScreen', 'combatScreen', 'rewardScreen', 'eventScreen', 'restScreen', 'shopScreen', 'victoryScreen', 'defeatScreen'].forEach(id => $(id).classList.add('hidden'));
      $('topBar').classList.toggle('hidden', state === 'menu');

      if (state === 'menu') {
        $('menuScreen').classList.remove('hidden');
        $('continueBtn').classList.toggle('hidden', !localStorage.getItem('slayv2-auto'));
      } else if (state === 'map') {
        $('mapScreen').classList.remove('hidden');
        renderMapScreen();
      } else if (state === 'combat') {
        $('combatScreen').classList.remove('hidden');
        renderCombat();
      } else if (state === 'reward') {
        $('rewardScreen').classList.remove('hidden');
        renderReward();
      } else if (state === 'event') {
        $('eventScreen').classList.remove('hidden');
        renderEvent();
      } else if (state === 'rest') {
        $('restScreen').classList.remove('hidden');
        renderRest();
      } else if (state === 'shop') {
        $('shopScreen').classList.remove('hidden');
        renderShop();
      } else if (state === 'victory') {
        $('victoryScreen').classList.remove('hidden');
        $('victoryStats').innerHTML = `ë„ë‹¬ ì¸µìˆ˜: ${floor}<br>ë‚¨ì€ HP: ${hp}/${maxHp}<br>ë³´ìœ  ê¸ˆí™”: ${gold}<br>ë ë¦­: ${relics.length}ê°œ<br>ë±: ${deck.length}ì¥<br>ì´ ê³µê²© íšŸìˆ˜: ${attackCounter}`;
      } else if (state === 'defeat') {
        $('defeatScreen').classList.remove('hidden');
        $('defeatSub').textContent = `${floor}ì¸µì—ì„œ ì“°ëŸ¬ì¡ŒìŠµë‹ˆë‹¤`;
        $('defeatStats').innerHTML = `HP: ${hp}/${maxHp}<br>ê¸ˆí™”: ${gold}<br>ë ë¦­: ${relics.length}ê°œ<br>ë±: ${deck.length}ì¥`;
      }

      $('floorNum').textContent = floor;
      $('hpText').textContent = `${hp}/${maxHp}`;
      $('goldText').textContent = gold;
      renderInventory();
    }

    function renderInventory() {
      let potionHtml = '';
      for (let i = 0; i < 3; i++) {
        const p = potions[i];
        potionHtml += `<div class="inv-slot" onclick="usePotion(${i})" title="${p ? p.name + ': ' + p.desc : 'ë¹ˆ ìŠ¬ë¡¯'}">${p ? p.emoji : 'â—‹'}</div>`;
      }
      $('potionSlots').innerHTML = potionHtml;
      $('relicSlots').innerHTML = relics.slice(0, 5).map(r => `<div class="inv-slot" title="${r.name}: ${r.desc}">${r.emoji}</div>`).join('');
    }

    function renderMapScreen() {
      $('mapAiMsg').querySelector('p').textContent = aiMsg ? `"${aiMsg}"` : '';
      $('mapAiMsg').classList.toggle('hidden', !aiMsg);
      $('mapMsg').textContent = gameMsg;

      const nextRow = currentNode ? mapNodes[currentNode.row + 1] : mapNodes[0];
      const nodes = nextRow ? nextRow.filter(n => isAccessible(n)) : [];
      $('quickSelect').innerHTML = nodes.map(n => `<button class="quick-btn" onclick="selectNode('${n.id}')" title="${NODE_NAMES[n.type]}">${NODE_ICONS[n.type]}</button>`).join('');
    }

    function renderCombat() {
      if (!enemies.length) return;
      
      $('combatAiMsg').querySelector('p').textContent = aiMsg ? `"${aiMsg}"` : '';
      $('combatAiMsg').classList.toggle('hidden', !aiMsg);
      $('combatMsg').textContent = gameMsg;

      // ì  ë Œë”ë§
      let enemyHtml = '';
      enemies.forEach((e, idx) => {
        if (e.hp <= 0) return;
        
        let st = '';
        if (e.block > 0) st += `<span class="status block">ğŸ›¡ï¸${e.block}</span>`;
        if (e.strength > 0) st += `<span class="status str">âš”ï¸+${e.strength}</span>`;
        if (e.vulnerable > 0) st += `<span class="status vuln">ì·¨ì•½${e.vulnerable}</span>`;
        if (e.weak > 0) st += `<span class="status weak">ì•½í™”${e.weak}</span>`;
        if (e.ritual > 0) st += `<span class="status ritual">ì˜ì‹${e.ritual}</span>`;
        if (e.poison > 0) st += `<span class="status poison">ë…${e.poison}</span>`;

        let intentHtml = '';
        const intent = e.intent;
        if (intent) {
          if (intent.dmg !== undefined) {
            let dmg = intent.dmg + (e.strength || 0);
            if (e.weak > 0) dmg = Math.floor(dmg * 0.75);
            const times = intent.times || 1;
            const totalDmg = dmg * times;
            intentHtml = `<span class="red">âš”ï¸ ${totalDmg}${times > 1 ? ` (${dmg}Ã—${times})` : ''}</span>`;
          } else if (intent.block) {
            intentHtml = `<span class="blue">ğŸ›¡ï¸ ë°©ì–´</span>`;
          } else if (intent.debuff) {
            intentHtml = `<span class="purple">ğŸ’€ ë””ë²„í”„</span>`;
          } else {
            intentHtml = `<span class="gold">âœ¨ ë²„í”„</span>`;
          }
        }

        enemyHtml += `
          <div class="enemy-unit" onclick="targetEnemy(${idx})">
            ${targetMode ? '<div class="target-indicator">â¬‡ï¸</div>' : ''}
            <div class="enemy-emoji" id="enemy-${idx}">${e.emoji}</div>
            <div class="enemy-name">${e.name}</div>
            <div class="hp-bar"><div class="hp-fill" style="width:${Math.max(0, e.hp / e.maxHp * 100)}%"></div></div>
            <div class="muted" style="font-size:12px;"><span class="red">${Math.max(0, e.hp)}</span> / ${e.maxHp}</div>
            <div>${st}</div>
            <div class="intent">${intentHtml}</div>
          </div>
        `;
      });
      $('enemyContainer').innerHTML = enemyHtml;

      // í”Œë ˆì´ì–´ ìƒíƒœ
      $('playerHp').textContent = `${hp}/${maxHp}`;
      $('playerBlock').style.display = block > 0 ? 'flex' : 'none';
      $('playerBlock').querySelector('span:last-child').textContent = block;
      $('playerStr').style.display = strength > 0 ? 'inline-block' : 'none';
      $('playerStr').textContent = `âš”ï¸+${strength}`;
      $('playerDex').style.display = dexterity > 0 ? 'inline-block' : 'none';
      $('playerDex').textContent = `ğŸ›¡ï¸+${dexterity}`;
      $('playerWeak').style.display = weak > 0 ? 'inline-block' : 'none';
      $('playerWeak').textContent = `ì•½í™”${weak}`;
      $('playerVuln').style.display = vulnerable > 0 ? 'inline-block' : 'none';
      $('playerVuln').textContent = `ì·¨ì•½${vulnerable}`;
      $('playerPoison').style.display = poison > 0 ? 'inline-block' : 'none';
      $('playerPoison').textContent = `ë…${poison}`;

      // ì—ë„ˆì§€ ì˜¤ë¸Œ
      let orbs = '';
      for (let i = 0; i < maxEnergy; i++) {
        orbs += `<div class="orb ${i < energy ? 'active' : 'empty'}">${i < energy ? 'âš¡' : ''}</div>`;
      }
      $('energyOrbs').innerHTML = orbs;

      // ë± ì¹´ìš´íŠ¸
      $('drawCount').textContent = drawPile.length;
      $('discardCount').textContent = discardPile.length;
      $('exhaustCount').textContent = exhaustPile.length;

      // ì†íŒ¨
      $('handArea').innerHTML = hand.map((c, i) => cardHtml(c, i, c.cost > energy)).join('');
      $('endTurnBtn').disabled = animating;

      // ì „íˆ¬ ë¡œê·¸
      let logHtml = '';
      combatLogs.slice(-5).forEach(l => {
        logHtml += `<p class="${l.type}">${l.msg}</p>`;
      });
      $('combatLog').innerHTML = logHtml;
    }

    function cardHtml(c, i, dis) {
      const icon = c.type === 'attack' ? 'âš”ï¸' : c.type === 'skill' ? 'ğŸ›¡ï¸' : 'âœ¨';
      const upgradedClass = c.upgraded ? 'upgraded' : '';
      return `<div class="game-card ${c.type} ${upgradedClass} ${dis ? 'disabled' : ''}" onclick="playCard(${i})">
        <div class="card-cost">${c.cost}</div>
        ${c.upgraded ? '<div class="card-upgrade-badge">+</div>' : ''}
        <div class="card-icon">${icon}</div>
        <div class="card-name">${c.name}</div>
        <div class="card-desc">${c.desc}</div>
      </div>`;
    }

    function renderReward() {
      let html = '';
      if (rewardGold > 0) html += `<button class="choice-btn" onclick="collectGold()">ğŸ’° ê¸ˆí™” ${rewardGold}ê°œ íšë“</button>`;
      if (rewardPotion) html += `<button class="choice-btn" onclick="collectPotion()" ${potions.length >= 3 ? 'disabled' : ''}>${rewardPotion.emoji} ${rewardPotion.name} ${potions.length >= 3 ? '(ê°€ë“ì°¸)' : ''}</button>`;
      if (rewardRelic) html += `<button class="choice-btn" onclick="collectRelic()">${rewardRelic.emoji} ${rewardRelic.name} (${rewardRelic.desc})</button>`;
      if (rewardCards.length > 0) {
        html += `<p class="muted" style="margin:12px 0 8px;">ì¹´ë“œ ì„ íƒ (1ì¥)</p><div style="display:flex;justify-content:center;gap:8px;flex-wrap:wrap;">`;
        rewardCards.forEach((c, i) => {
          const icon = c.type === 'attack' ? 'âš”ï¸' : c.type === 'skill' ? 'ğŸ›¡ï¸' : 'âœ¨';
          html += `<div class="game-card ${c.type}" onclick="selectRewardCard(${i})">
            <div class="card-cost">${c.cost}</div>
            <div class="card-icon">${icon}</div>
            <div class="card-name">${c.name}</div>
            <div class="card-desc">${c.desc}</div>
          </div>`;
        });
        html += `</div><button class="btn btn-dark btn-sm" style="margin-top:12px;" onclick="skipRewardCard()">ê±´ë„ˆë›°ê¸°</button>`;
      }
      if (!rewardGold && !rewardPotion && !rewardRelic && !rewardCards.length) {
        html += `<button class="btn btn-gold" onclick="finishReward()">ê³„ì†í•˜ê¸°</button>`;
      }
      $('rewardContent').innerHTML = html;
    }

    function renderEvent() {
      if (!currentEvent) return;
      let html = `<div class="event-emoji">${currentEvent.emoji}</div>
        <div class="event-title">${currentEvent.title}</div>
        <div class="event-desc">${currentEvent.desc}</div>`;
      currentEvent.choices.forEach((c, i) => {
        let disabled = '';
        if (c.damage && hp <= c.damage) disabled = 'disabled';
        if (c.maxHpLoss && maxHp <= c.maxHpLoss + 10) disabled = 'disabled';
        html += `<button class="choice-btn" onclick="chooseEvent(${i})" ${disabled}>${c.text}</button>`;
      });
      $('eventBox').innerHTML = html;
    }

    function renderRest() {
      let html = `<div class="event-emoji">ğŸ”¥</div>
        <div class="event-title">ëª¨ë‹¥ë¶ˆ</div>
        <div class="event-desc">ë”°ëœ»í•œ ëª¨ë‹¥ë¶ˆ ì•ì—ì„œ ì‰¬ì–´ê°‘ë‹ˆë‹¤.</div>
        <button class="choice-btn" onclick="restHeal()">ğŸ˜´ íœ´ì‹ (HP 30% íšŒë³µ)</button>
        <button class="choice-btn" onclick="restUpgrade()">â¬†ï¸ ëŒ€ì¥ì¥ì´ (ì¹´ë“œ ì—…ê·¸ë ˆì´ë“œ)</button>`;
      $('restBox').innerHTML = html;
    }

    function renderShop() {
      $('shopGold').textContent = gold;
      $('shopAiMsg').querySelector('p').textContent = aiMsg ? `"${aiMsg}"` : '';
      $('shopMsg').textContent = gameMsg;

      if (!shopItems) return;
      let html = '';
      
      // ì„œë¹„ìŠ¤
      html += `<div class="shop-section"><div class="shop-title">ì„œë¹„ìŠ¤</div>`;
      html += `<div class="shop-service ${shopItems.removeUsed ? 'sold' : ''}" onclick="shopRemoveCard()">
        <span>ğŸ—‘ï¸ ì¹´ë“œ ì œê±°</span>
        <span class="gold">ğŸ’° ${shopItems.removePrice}</span>
      </div></div>`;

      // ì¹´ë“œ
      html += `<div class="shop-section"><div class="shop-title">ì¹´ë“œ</div><div class="shop-items">`;
      shopItems.cards.forEach((it, i) => {
        const c = it.item;
        const icon = c.type === 'attack' ? 'âš”ï¸' : c.type === 'skill' ? 'ğŸ›¡ï¸' : 'âœ¨';
        html += `<div class="shop-item ${it.sold ? 'sold' : ''}" onclick="buyCard(${i})">
          <div class="game-card small ${c.type}">
            <div class="card-cost">${c.cost}</div>
            <div class="card-icon">${icon}</div>
            <div class="card-name">${c.name}</div>
            <div class="card-desc">${c.desc}</div>
          </div>
          <div class="shop-price">ğŸ’° ${it.price}</div>
        </div>`;
      });
      html += `</div></div>`;

      // í¬ì…˜
      html += `<div class="shop-section"><div class="shop-title">í¬ì…˜</div><div class="shop-items">`;
      shopItems.potions.forEach((it, i) => {
        html += `<div class="shop-item ${it.sold ? 'sold' : ''}" onclick="buyPotion(${i})" style="min-width:100px;text-align:center;">
          <div style="font-size:26px;">${it.item.emoji}</div>
          <div style="font-size:12px;">${it.item.name}</div>
          <div class="shop-price">ğŸ’° ${it.price}</div>
        </div>`;
      });
      html += `</div></div>`;

      // ë ë¦­
      if (shopItems.relics && shopItems.relics.length > 0) {
        html += `<div class="shop-section"><div class="shop-title">ë ë¦­</div><div class="shop-items">`;
        shopItems.relics.forEach((it, i) => {
          html += `<div class="shop-item ${it.sold ? 'sold' : ''}" onclick="buyRelic(${i})" style="min-width:100px;text-align:center;">
            <div style="font-size:30px;">${it.item.emoji}</div>
            <div style="font-size:12px;">${it.item.name}</div>
            <div style="font-size:10px;color:#888;">${it.item.desc}</div>
            <div class="shop-price">ğŸ’° ${it.price}</div>
          </div>`;
        });
        html += `</div></div>`;
      }

      $('shopContent').innerHTML = html;
    }

    function renderSaveSlots() {
      let html = '';
      for (let i = 0; i < 3; i++) {
        const raw = localStorage.getItem('slayv2-' + i);
        const d = raw ? JSON.parse(raw) : null;
        html += `<div class="save-slot">
          <div class="save-head"><span class="save-name">ìŠ¬ë¡¯ ${i + 1}</span>${d ? `<span class="save-date">${d.savedAt}</span>` : ''}</div>
          <div class="save-info">${d ? `${d.floor}ì¸µ | HP: ${d.hp}/${d.maxHp} | ğŸ’°${d.gold} | ë±: ${d.deck.length}ì¥` : 'ë¹„ì–´ìˆìŒ'}</div>
          <div class="save-btns">
            <button class="btn btn-dark" onclick="save(${i})" ${state === 'menu' ? 'disabled' : ''}>ì €ì¥</button>
            <button class="btn btn-dark" onclick="load(${i})" ${!d ? 'disabled' : ''}>ë¶ˆëŸ¬ì˜¤ê¸°</button>
            ${d ? `<button class="btn btn-dark" style="flex:none;padding:10px 14px;" onclick="delSave(${i})">ğŸ—‘ï¸</button>` : ''}
          </div>
        </div>`;
      }
      $('saveSlots').innerHTML = html;
    }

    // ========== ëª¨ë‹¬ ==========
    function showSaveMenu() { $('saveModal').classList.remove('hidden'); renderSaveSlots(); }
    function closeSaveMenu() { $('saveModal').classList.add('hidden'); }
    
    function showDeck() {
      $('deckModal').classList.remove('hidden');
      $('deckCount').textContent = deck.length;
      
      // í•„í„° ë²„íŠ¼
      $('deckFilter').innerHTML = `
        <button class="active" onclick="filterDeck('all')">ì „ì²´</button>
        <button onclick="filterDeck('attack')">ê³µê²©</button>
        <button onclick="filterDeck('skill')">ìŠ¤í‚¬</button>
        <button onclick="filterDeck('power')">íŒŒì›Œ</button>
      `;
      
      renderDeckGrid('all');
    }
    
    function filterDeck(type) {
      document.querySelectorAll('.deck-filter button').forEach(b => b.classList.remove('active'));
      event.target.classList.add('active');
      renderDeckGrid(type);
    }
    
    function renderDeckGrid(filter) {
      let cards = filter === 'all' ? deck : deck.filter(c => c.type === filter);
      cards = cards.sort((a, b) => a.cost - b.cost);
      
      let html = '';
      cards.forEach(c => {
        const icon = c.type === 'attack' ? 'âš”ï¸' : c.type === 'skill' ? 'ğŸ›¡ï¸' : 'âœ¨';
        const upgradedClass = c.upgraded ? 'upgraded' : '';
        html += `<div class="game-card small ${c.type} ${upgradedClass}">
          <div class="card-cost">${c.cost}</div>
          ${c.upgraded ? '<div class="card-upgrade-badge">+</div>' : ''}
          <div class="card-icon">${icon}</div>
          <div class="card-name">${c.name}</div>
          <div class="card-desc">${c.desc}</div>
        </div>`;
      });
      $('deckGrid').innerHTML = html;
    }
    
    function closeDeck() { $('deckModal').classList.add('hidden'); }
    
    function showMap() {
      $('mapModal').classList.remove('hidden');
      $('mapLegend').innerHTML = Object.entries(NODE_ICONS).map(([k, v]) => `<span>${v} ${NODE_NAMES[k]}</span>`).join('');
      
      const boxWidth = 420;
      const floorHeight = 34;
      const nodeSize = 40;
      
      // ë…¸ë“œ ìœ„ì¹˜ ê³„ì‚°
      const nodePositions = {};
      mapNodes.forEach((row, ri) => {
        row.forEach((n, ci) => {
          const numNodes = row.length;
          const spacing = boxWidth / (numNodes + 1);
          const x = spacing * (ci + 1);
          const y = (mapNodes.length - 1 - ri) * floorHeight + 25;
          nodePositions[n.id] = { x, y };
        });
      });
      
      // SVG ê²½ë¡œ ìƒì„±
      let pathsHtml = `<svg class="map-paths" width="${boxWidth}" height="${mapNodes.length * floorHeight + 30}">`;
      
      mapNodes.forEach((row, ri) => {
        row.forEach(node => {
          const from = nodePositions[node.id];
          node.connections.forEach(connId => {
            const to = nodePositions[connId];
            if (from && to) {
              let pathClass = 'map-path';
              
              // ê²½ë¡œ ìƒíƒœ ê²°ì •
              const isCurrentNode = currentNode && currentNode.id === node.id;
              const isVisitedPath = visitedNodes.includes(node.id) && visitedNodes.includes(connId);
              const isFromVisited = visitedNodes.includes(node.id);
              
              if (isVisitedPath) {
                pathClass += ' visited';
              } else if (isCurrentNode) {
                // í˜„ì¬ ë…¸ë“œì—ì„œ ë‚˜ê°€ëŠ” ê²½ë¡œëŠ” ì„ íƒ ê°€ëŠ¥
                pathClass += ' accessible';
              }
              
              // ê³¡ì„  ê²½ë¡œ (ë² ì§€ì–´ ì»¤ë¸Œ)
              const midY = (from.y + to.y) / 2;
              const ctrlX = (from.x + to.x) / 2;
              pathsHtml += `<path class="${pathClass}" d="M${from.x},${from.y} Q${ctrlX},${midY} ${to.x},${to.y}"/>`;
            }
          });
        });
      });
      
      pathsHtml += '</svg>';
      
      // ë…¸ë“œ HTML ìƒì„±
      let nodesHtml = '<div class="map-container">' + pathsHtml;
      
      for (let ri = mapNodes.length - 1; ri >= 0; ri--) {
        const row = mapNodes[ri];
        nodesHtml += `<div class="map-floor">`;
        
        row.forEach(n => {
          let cls = 'map-node ';
          if (currentNode && currentNode.id === n.id) cls += 'current';
          else if (visitedNodes.includes(n.id)) cls += 'visited';
          else if (isAccessible(n)) cls += 'accessible';
          else cls += 'locked';
          
          nodesHtml += `<div class="${cls}" onclick="selectNode('${n.id}')" title="${NODE_NAMES[n.type]}">${NODE_ICONS[n.type]}</div>`;
        });
        
        nodesHtml += `</div>`;
      }
      
      nodesHtml += '</div>';
      
      $('mapBox').innerHTML = nodesHtml;
    }
    function closeMap() { $('mapModal').classList.add('hidden'); }

    function showUpgrade() {
      $('upgradeModal').classList.remove('hidden');
      const upgradeable = deck.filter(c => !c.upgraded);
      let html = '';
      upgradeable.forEach((c, i) => {
        const icon = c.type === 'attack' ? 'âš”ï¸' : c.type === 'skill' ? 'ğŸ›¡ï¸' : 'âœ¨';
        const originalIdx = deck.indexOf(c);
        html += `<div class="game-card small ${c.type}" onclick="doUpgrade(${originalIdx})">
          <div class="card-cost">${c.cost}</div>
          <div class="card-icon">${icon}</div>
          <div class="card-name">${c.name}</div>
          <div class="card-desc">${c.desc}</div>
        </div>`;
      });
      if (!upgradeable.length) html = '<p class="muted center">ì—…ê·¸ë ˆì´ë“œí•  ì¹´ë“œê°€ ì—†ìŠµë‹ˆë‹¤</p>';
      $('upgradeGrid').innerHTML = html;
    }
    function closeUpgrade() { $('upgradeModal').classList.add('hidden'); }
    
    function doUpgrade(idx) {
      upgradeCard(deck[idx]);
      closeUpgrade();
      gameMsg = `${deck[idx].name} ì—…ê·¸ë ˆì´ë“œ!`;
      state = 'map';
      autoSave();
      render();
    }

    function showRemove() {
      $('removeModal').classList.remove('hidden');
      let html = '';
      deck.forEach((c, i) => {
        const icon = c.type === 'attack' ? 'âš”ï¸' : c.type === 'skill' ? 'ğŸ›¡ï¸' : 'âœ¨';
        const upgradedClass = c.upgraded ? 'upgraded' : '';
        html += `<div class="game-card small ${c.type} ${upgradedClass}" onclick="doRemove(${i})">
          <div class="card-cost">${c.cost}</div>
          ${c.upgraded ? '<div class="card-upgrade-badge">+</div>' : ''}
          <div class="card-icon">${icon}</div>
          <div class="card-name">${c.name}</div>
          <div class="card-desc">${c.desc}</div>
        </div>`;
      });
      $('removeGrid').innerHTML = html;
    }
    function closeRemove() { $('removeModal').classList.add('hidden'); }
    
    function doRemove(idx) {
      const removed = deck.splice(idx, 1)[0];
      closeRemove();
      gameMsg = `${removed.name} ì œê±°ë¨`;
      if (shopItems) shopItems.removeUsed = true;
      render();
    }

    // ========== ê²Œì„ ë¡œì§ ==========
    function startGame() {
      deck = [
        ...Array(5).fill(null).map(() => createCard('strike')),
        ...Array(4).fill(null).map(() => createCard('defend')),
        createCard('bash')
      ];
      hp = 80; maxHp = 80; gold = 99; floor = 1;
      relics = [{ ...RELICS.blood, key: 'blood', uid: uid() }];
      potions = [];
      energy = 3; maxEnergy = 3; powers = {};
      strength = 0; dexterity = 0; weak = 0; vulnerable = 0; poison = 0;
      mapNodes = generateMap();
      combatLogs = []; attackCounter = 0;
      
      // ì‹œì‘ ë…¸ë“œ ìë™ ë°©ë¬¸ ì²˜ë¦¬
      const startNode = mapNodes[0][0];
      currentNode = startNode;
      visitedNodes = [startNode.id];
      
      state = 'map'; aiMsg = 'ì²¨íƒ‘ì— ë°œì„ ë“¤ì˜€ìŠµë‹ˆë‹¤...'; gameMsg = '';
      render();
    }

    function generateMap() {
      const nodes = [];
      const numFloors = 15;
      const nodesPerFloor = [1, 3, 3, 4, 3, 4, 3, 4, 3, 4, 3, 3, 2, 1, 1];
      
      // ë…¸ë“œ ìƒì„±
      for (let r = 0; r < numFloors; r++) {
        const row = [];
        const numNodes = nodesPerFloor[r];
        
        for (let c = 0; c < numNodes; c++) {
          let type = 'enemy';
          
          if (r === 0) type = 'start';
          else if (r === numFloors - 1) type = 'boss';
          else if (r === numFloors - 2) type = 'rest';  // ë³´ìŠ¤ ì „ íœ´ì‹
          else if (r === 8) type = 'treasure';  // ì¤‘ê°„ ë³´ë¬¼
          else {
            // ì¸µë³„ í™•ë¥  ì¡°ì •
            const x = Math.random();
            if (r <= 3) {
              // ì´ˆë°˜: ì  ë§ìŒ
              if (x < 0.55) type = 'enemy';
              else if (x < 0.70) type = 'event';
              else if (x < 0.85) type = 'rest';
              else if (x < 0.95) type = 'shop';
              else type = 'elite';
            } else if (r <= 7) {
              // ì¤‘ë°˜: ì—˜ë¦¬íŠ¸ ë“±ì¥
              if (x < 0.45) type = 'enemy';
              else if (x < 0.58) type = 'event';
              else if (x < 0.70) type = 'rest';
              else if (x < 0.80) type = 'shop';
              else if (x < 0.92) type = 'elite';
              else type = 'treasure';
            } else {
              // í›„ë°˜: íœ´ì‹/ìƒì  ë§ìŒ
              if (x < 0.40) type = 'enemy';
              else if (x < 0.55) type = 'event';
              else if (x < 0.72) type = 'rest';
              else if (x < 0.85) type = 'shop';
              else type = 'elite';
            }
          }
          
          // x ì¢Œí‘œ ê³„ì‚° (ì‹œê°ì  ë°°ì¹˜ìš©)
          const spacing = 100 / (numNodes + 1);
          const xPos = spacing * (c + 1);
          
          row.push({ 
            id: `${r}-${c}`, 
            row: r, 
            col: c, 
            type, 
            connections: [],
            x: xPos
          });
        }
        nodes.push(row);
      }
      
      // Slay the Spire ìŠ¤íƒ€ì¼ ì—°ê²° ìƒì„±
      for (let r = 0; r < numFloors - 1; r++) {
        const currRow = nodes[r];
        const nextRow = nodes[r + 1];
        
        // 1ë‹¨ê³„: ê° ë…¸ë“œì—ì„œ 1~2ê°œ ì—°ê²° ìƒì„± (ê°€ê¹Œìš´ ë…¸ë“œ ìš°ì„ )
        currRow.forEach(node => {
          // ë‹¤ìŒ ì¸µ ë…¸ë“œë“¤ì„ ê±°ë¦¬ìˆœìœ¼ë¡œ ì •ë ¬
          const sortedNext = [...nextRow].sort((a, b) => {
            return Math.abs(a.x - node.x) - Math.abs(b.x - node.x);
          });
          
          // ê°€ì¥ ê°€ê¹Œìš´ ë…¸ë“œëŠ” ë°˜ë“œì‹œ ì—°ê²°
          if (sortedNext.length > 0) {
            node.connections.push(sortedNext[0].id);
          }
          
          // ë‘ ë²ˆì§¸ë¡œ ê°€ê¹Œìš´ ë…¸ë“œëŠ” 60% í™•ë¥ ë¡œ ì—°ê²°
          if (sortedNext.length > 1 && Math.random() < 0.6) {
            node.connections.push(sortedNext[1].id);
          }
          
          // ì„¸ ë²ˆì§¸ ë…¸ë“œëŠ” 20% í™•ë¥ ë¡œ ì—°ê²°
          if (sortedNext.length > 2 && Math.random() < 0.2) {
            node.connections.push(sortedNext[2].id);
          }
        });
        
        // 2ë‹¨ê³„: ëª¨ë“  ë‹¤ìŒ ì¸µ ë…¸ë“œê°€ ìµœì†Œ 1ê°œ ì§„ì… ê²½ë¡œ ê°–ë„ë¡ ë³´ì¥
        nextRow.forEach(nextNode => {
          const hasIncoming = currRow.some(n => n.connections.includes(nextNode.id));
          if (!hasIncoming) {
            // ê°€ì¥ ê°€ê¹Œìš´ ì´ì „ ì¸µ ë…¸ë“œì™€ ì—°ê²°
            const closest = currRow.reduce((best, n) => {
              const dist = Math.abs(n.x - nextNode.x);
              return dist < best.dist ? { node: n, dist } : best;
            }, { node: currRow[0], dist: Infinity });
            closest.node.connections.push(nextNode.id);
          }
        });
      }
      
      // 3ë‹¨ê³„: ê²½ë¡œê°€ êµì°¨í•˜ì§€ ì•Šë„ë¡ ì •ë¦¬ (ì„ íƒì )
      for (let r = 0; r < numFloors - 1; r++) {
        const currRow = nodes[r];
        currRow.forEach(node => {
          // ì¤‘ë³µ ì œê±°
          node.connections = [...new Set(node.connections)];
        });
      }
      
      return nodes;
    }

    function isAccessible(n) {
      if (visitedNodes.includes(n.id)) return false;
      if (!currentNode) return n.row === 0;
      return currentNode.connections.includes(n.id);
    }

    function findNode(id) {
      for (let row of mapNodes) {
        for (let n of row) {
          if (n.id === id) return n;
        }
      }
      return null;
    }

    function selectNode(id) {
      // ì „íˆ¬/ì´ë²¤íŠ¸/ìƒì  ë“± ì§„í–‰ ì¤‘ì—ëŠ” ì´ë™ ë¶ˆê°€
      if (state === 'combat' || state === 'event' || state === 'rest' || state === 'shop' || state === 'reward') {
        gameMsg = 'í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ì´ë²¤íŠ¸ë¥¼ ì™„ë£Œí•˜ì„¸ìš”';
        render();
        return;
      }
      
      const n = findNode(id);
      if (!n || !isAccessible(n)) { 
        gameMsg = 'ì´ë™í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤'; 
        render(); 
        return; 
      }
      
      currentNode = n;
      visitedNodes.push(n.id);
      floor = n.row + 1;
      closeMap();
      gameMsg = ''; aiMsg = '';
      setTimeout(autoSave, 100);

      switch (n.type) {
        case 'start': state = 'map'; break;
        case 'enemy': startCombat('normal'); break;
        case 'elite': startCombat('elite'); break;
        case 'boss': startCombat('boss'); break;
        case 'event': triggerEvent(); break;
        case 'rest': triggerRest(); break;
        case 'shop': triggerShop(); break;
        case 'treasure': triggerTreasure(); break;
        default: state = 'map';
      }
      render();
    }

    function startCombat(type) {
      let pool, key;
      
      if (type === 'boss') {
        pool = ['slimeBoss', 'guardian', 'hexaghost'];
      } else if (type === 'elite') {
        pool = ['gremlinNob', 'lagavulin'];
      } else {
        pool = ['cultist', 'jawWorm', 'slimeM', 'looter'];
        // ê°€ë” ìŠ¬ë¼ì„ 2ë§ˆë¦¬
        if (Math.random() < 0.2) {
          pool = ['slimeS'];
        }
      }
      
      key = pool[rand(0, pool.length - 1)];
      const data = ENEMIES[key];
      
      enemies = [];
      const count = (key === 'slimeS' || key === 'sentries') ? (data.count || 2) : 1;
      
      for (let i = 0; i < count; i++) {
        const ehp = rand(data.hp[0], data.hp[1]);
        const e = {
          ...data, key, 
          hp: ehp, maxHp: ehp, 
          block: 0, strength: 0, ritual: 0, 
          weak: 0, vulnerable: 0, poison: 0,
          uid: uid()
        };
        e.intent = data.atks[rand(0, data.atks.length - 1)];
        enemies.push(e);
      }
      
      // ì´ˆê¸°í™”
      turn = 1; block = 0; weak = 0; vulnerable = 0; poison = 0;
      dexterity = 0; powers = {}; exhaustPile = []; combatLogs = [];
      cantDrawThisTurn = false; firstTurn = true;
      
      // ë ë¦­ íš¨ê³¼
      let bBlock = 0, bStr = 0, bEnergy = 0;
      relics.forEach(r => {
        if (r.startBlock) bBlock += r.startBlock;
        if (r.startStr) bStr += r.startStr;
        if (r.firstTurnEnergy && firstTurn) bEnergy += r.firstTurnEnergy;
        if (r.startVuln) enemies.forEach(e => e.vulnerable += r.startVuln);
        if (r.startVulnAll) enemies.forEach(e => e.vulnerable += r.startVulnAll);
      });
      
      // ë± ì„ê¸° ë° ë“œë¡œìš°
      const shuffled = shuffle([...deck]);
      drawPile = shuffled.slice(5);
      hand = shuffled.slice(0, 5);
      discardPile = [];
      
      energy = maxEnergy + bEnergy;
      block = bBlock;
      strength = bStr;
      
      aiMsg = data.boss ? 'ê°•ë ¥í•œ ì  ì¶œí˜„!' : data.elite ? 'ì—˜ë¦¬íŠ¸ì™€ ì¡°ìš°!' : 'ì ê³¼ ì¡°ìš°!';
      gameMsg = '';
      state = 'combat';
      
      addCombatLog(`${enemies.map(e => e.name).join(', ')}ì™€(ê³¼) ì „íˆ¬ ì‹œì‘!`);
    }

    function targetEnemy(idx) {
      if (!targetMode || selectedCardIndex < 0) return;
      targetMode = false;
      executeCard(selectedCardIndex, idx);
      selectedCardIndex = -1;
    }

    function playCard(i) {
      if (animating || state !== 'combat') return;
      const c = hand[i];
      if (c.cost > energy) { 
        gameMsg = 'ì—ë„ˆì§€ ë¶€ì¡±!'; 
        render(); 
        return; 
      }

      // íƒ€ê²Ÿì´ í•„ìš”í•œ ì¹´ë“œ ì²˜ë¦¬
      const aliveEnemies = enemies.filter(e => e.hp > 0);
      if (c.type === 'attack' && !c.aoe && aliveEnemies.length > 1) {
        targetMode = true;
        selectedCardIndex = i;
        gameMsg = 'ëŒ€ìƒì„ ì„ íƒí•˜ì„¸ìš”';
        render();
        return;
      }
      
      executeCard(i, 0);
    }

    function executeCard(i, targetIdx) {
      const c = hand[i];
      animating = true;
      energy -= c.cost;
      
      const e = enemies.filter(en => en.hp > 0)[targetIdx] || enemies.find(en => en.hp > 0);
      let msgs = [];

      // ê³µê²© ì¹´ë“œ
      if (c.type === 'attack') {
        attackCounter++;
        
        // íœì´‰ ë ë¦­ í™•ì¸
        let penNibBonus = 1;
        const penNib = relics.find(r => r.doubleEvery);
        if (penNib && attackCounter % penNib.doubleEvery === 0) {
          penNibBonus = 2;
          msgs.push('íœì´‰ ë°œë™!');
        }
        
        // ë°ë¯¸ì§€ ê³„ì‚°
        let baseDmg = c.damage || 0;
        if (c.blockDamage) baseDmg = block; // ëª¸í†µë°•ì¹˜ê¸°
        
        let strBonus = strength;
        if (c.strMult) strBonus = strength * c.strMult; // í—¤ë¹„ë¸”ë ˆì´ë“œ
        
        let dmg = baseDmg + strBonus;
        if (weak > 0) dmg = Math.floor(dmg * 0.75);
        dmg *= penNibBonus;
        
        const times = c.times || 1;
        const targets = c.aoe ? enemies.filter(en => en.hp > 0) : [e];
        
        targets.forEach(target => {
          for (let t = 0; t < times; t++) {
            let finalDmg = dmg;
            
            // ì·¨ì•½ ë³´ë„ˆìŠ¤ (ì¢…ì´ ê°œêµ¬ë¦¬ í¬í•¨)
            if (target.vulnerable > 0) {
              let vulnMult = 1.5;
              const paperFrog = relics.find(r => r.vulnBonus);
              if (paperFrog) vulnMult += paperFrog.vulnBonus;
              finalDmg = Math.floor(finalDmg * vulnMult);
            }
            
            const absorbed = Math.min(finalDmg, target.block);
            target.block = Math.max(0, target.block - finalDmg);
            target.hp -= Math.max(0, finalDmg - absorbed);
            
            // ì  í”¼ê²© ì• ë‹ˆë©”ì´ì…˜
            const enemyEl = document.getElementById(`enemy-${enemies.indexOf(target)}`);
            if (enemyEl) {
              enemyEl.classList.add('hit');
              setTimeout(() => enemyEl.classList.remove('hit'), 300);
            }
          }
        });
        
        const totalDmg = dmg * times * targets.length;
        msgs.push(`${totalDmg} ë°ë¯¸ì§€`);
        addCombatLog(`${c.name} â†’ ${totalDmg} ë°ë¯¸ì§€`, 'dmg');
        
        // ë””ë²„í”„ ì ìš©
        if (c.vulnerable) { e.vulnerable += c.vulnerable; msgs.push(`ì·¨ì•½${c.vulnerable}`); }
        if (c.weak) { e.weak += c.weak; msgs.push(`ì•½í™”${c.weak}`); }
        
        // ë¶„ë…¸ (ê³µê²©ì‹œ ë°©ì–´)
        if (powers.blockOnAttack) {
          gainBlock(powers.blockOnAttack);
          msgs.push(`ë¶„ë…¸ë¡œ ${powers.blockOnAttack} ë°©ì–´`);
        }
      }
      
      // ë°©ì–´
      if (c.block) {
        gainBlock(c.block);
        msgs.push(`${c.block + dexterity} ë°©ì–´`);
        addCombatLog(`${c.name} â†’ ${c.block + dexterity} ë°©ì–´`, 'block');
      }
      
      // íŒŒì›Œ ì¹´ë“œ
      if (c.type === 'power') {
        if (c.strength) { strength += c.strength; msgs.push(`í˜+${c.strength}`); }
        if (c.endBlock) { powers.metal = (powers.metal || 0) + c.endBlock; msgs.push(`ê¸ˆì†í™” ${c.endBlock}`); }
        if (c.strPerTurn) { powers.demon = (powers.demon || 0) + c.strPerTurn; msgs.push(`ì•…ë§ˆí˜•ìƒ`); }
        if (c.blockOnAttack) { powers.blockOnAttack = (powers.blockOnAttack || 0) + c.blockOnAttack; }
        if (c.damageOnBlock) { powers.damageOnBlock = (powers.damageOnBlock || 0) + c.damageOnBlock; }
        addCombatLog(`${c.name} ë°œë™!`);
      }
      
      // ë“œë¡œìš°
      if (c.draw && !cantDrawThisTurn) {
        for (let d = 0; d < c.draw; d++) drawCard();
        msgs.push(`${c.draw} ë“œë¡œìš°`);
      }
      
      // ì—ë„ˆì§€ íšë“
      if (c.gainEnergy) {
        energy += c.gainEnergy;
        msgs.push(`ì—ë„ˆì§€+${c.gainEnergy}`);
      }
      
      // ìí•´
      if (c.selfDamage) {
        hp -= c.selfDamage;
        msgs.push(`HP-${c.selfDamage}`);
      }
      
      // ë“œë¡œìš° ë¶ˆê°€
      if (c.cantDraw) {
        cantDrawThisTurn = true;
      }
      
      // ë¬´ì¥ (ì—…ê·¸ë ˆì´ë“œ)
      if (c.upgradeHand) {
        const upgradeable = hand.filter(card => !card.upgraded && card !== c);
        if (upgradeable.length > 0) {
          if (c.upgradeAll) {
            upgradeable.forEach(card => upgradeCard(card));
            msgs.push('ì†íŒ¨ ì „ì²´ ì—…ê·¸ë ˆì´ë“œ!');
          } else {
            upgradeCard(upgradeable[rand(0, upgradeable.length - 1)]);
            msgs.push('ì¹´ë“œ 1ì¥ ì—…ê·¸ë ˆì´ë“œ');
          }
        }
      }
      
      // ë¶„ë…¸ (ë³µì‚¬ë³¸)
      if (c.addCopy) {
        const copy = createCard(c.key, c.upgraded);
        discardPile.push(copy);
      }
      
      // ì§„ì •í•œ íˆ¬ì§€ (ëœë¤ ì†Œë©¸)
      if (c.exhaustRandom && hand.length > 1) {
        const others = hand.filter((card, idx) => idx !== i);
        const toExhaust = others[rand(0, others.length - 1)];
        const exhaustIdx = hand.indexOf(toExhaust);
        hand.splice(exhaustIdx, 1);
        exhaustPile.push(toExhaust);
        msgs.push(`${toExhaust.name} ì†Œë©¸`);
      }

      gameMsg = msgs.join(', ') + '!';

      // ì¹´ë“œ ì²˜ë¦¬
      const played = hand.splice(i, 1)[0];
      if (c.exhaust) exhaustPile.push(played);
      else discardPile.push(played);

      render();
      
      setTimeout(() => {
        animating = false;
        checkEnemyDeath();
      }, 300);
    }

    function gainBlock(amount) {
      const total = amount + dexterity;
      block += total;
      
      // ì €ê±°ë„ˆíŠ¸
      if (powers.damageOnBlock) {
        const target = enemies.find(e => e.hp > 0);
        if (target) {
          const dmg = powers.damageOnBlock;
          const absorbed = Math.min(dmg, target.block);
          target.block -= absorbed;
          target.hp -= (dmg - absorbed);
          addCombatLog(`ì €ê±°ë„ˆíŠ¸ â†’ ${dmg} ë°ë¯¸ì§€`, 'dmg');
        }
      }
    }

    function drawCard() {
      if (cantDrawThisTurn) return;
      if (!drawPile.length && discardPile.length) {
        drawPile = shuffle(discardPile);
        discardPile = [];
      }
      if (drawPile.length && hand.length < 10) {
        hand.push(drawPile.pop());
      }
    }

    function checkEnemyDeath() {
      const allDead = enemies.every(e => e.hp <= 0);
      if (allDead) {
        combatVictory();
      } else if (hp <= 0) {
        defeat();
      } else {
        render();
      }
    }

    function endTurn() {
      if (animating) return;
      animating = true;
      
      // ì˜¤ë¦¬í•˜ë¥´ì½˜ ë ë¦­
      if (block === 0) {
        const ori = relics.find(r => r.noBlockGain);
        if (ori) {
          block += ori.noBlockGain;
          addCombatLog(`ì˜¤ë¦¬í•˜ë¥´ì½˜ â†’ ${ori.noBlockGain} ë°©ì–´`, 'block');
        }
      }
      
      // ê¸ˆì†í™”
      if (powers.metal) {
        gainBlock(powers.metal);
        addCombatLog(`ê¸ˆì†í™” â†’ ${powers.metal} ë°©ì–´`, 'block');
      }
      
      render();

      // ì  í„´
      setTimeout(() => {
        executeEnemyTurns();
      }, 400);
    }

    function executeEnemyTurns() {
      let delay = 0;
      
      enemies.forEach((e, idx) => {
        if (e.hp <= 0) return;
        
        setTimeout(() => {
          const intent = e.intent;
          
          // ë… ë°ë¯¸ì§€
          if (e.poison > 0) {
            e.hp -= e.poison;
            e.poison -= 1;
            addCombatLog(`${e.name} ë… â†’ ${e.poison + 1} ë°ë¯¸ì§€`, 'dmg');
          }
          
          if (e.hp <= 0) {
            render();
            return;
          }
          
          if (intent.dmg !== undefined) {
            let dmg = intent.dmg + (e.strength || 0);
            if (e.weak > 0) dmg = Math.floor(dmg * 0.75);
            
            const times = intent.times || 1;
            let totalDmg = 0;
            let totalBlocked = 0;
            
            // í† ë¦¬ì´ ë ë¦­
            const torii = relics.find(r => r.reduceLowDmg);
            
            for (let t = 0; t < times; t++) {
              let hitDmg = dmg;
              if (vulnerable > 0) hitDmg = Math.floor(hitDmg * 1.5);
              
              // í† ë¦¬ì´
              if (torii && hitDmg <= 5 && hitDmg > 0) hitDmg = 1;
              
              const absorbed = Math.min(hitDmg, block);
              block -= absorbed;
              hp -= (hitDmg - absorbed);
              totalDmg += hitDmg;
              totalBlocked += absorbed;
            }
            
            gameMsg = `${e.name} ê³µê²©! ${totalDmg}${totalBlocked > 0 ? ` (${totalBlocked} ë°©ì–´)` : ''}`;
            addCombatLog(gameMsg, 'dmg');
          } else if (intent.block) {
            e.block += intent.block;
            if (intent.str) e.strength += intent.str;
            gameMsg = `${e.name}ì´(ê°€) ë°©ì–´!`;
            addCombatLog(gameMsg, 'block');
          } else if (intent.ritual) {
            e.ritual += intent.ritual;
            gameMsg = `${e.name} ì˜ì‹! í˜+${intent.ritual}/í„´`;
            addCombatLog(gameMsg);
          } else if (intent.str) {
            e.strength += intent.str;
            gameMsg = `${e.name} ê°•í™”! í˜+${intent.str}`;
            addCombatLog(gameMsg);
          } else if (intent.debuff) {
            if (intent.strDown) strength = Math.max(0, strength - intent.strDown);
            if (intent.dexDown) dexterity = Math.max(0, dexterity - intent.dexDown);
            gameMsg = `${e.name} ë””ë²„í”„!`;
            addCombatLog(gameMsg);
          }
          
          // ì•½í™”/ì·¨ì•½ ì ìš©
          if (intent.weak) weak += intent.weak;
          
          render();
        }, delay);
        
        delay += 500;
      });
      
      // í„´ ì¢…ë£Œ ì²˜ë¦¬
      setTimeout(() => {
        if (hp <= 0) {
          defeat();
          return;
        }
        
        startNewTurn();
      }, delay + 300);
    }

    function startNewTurn() {
      turn++;
      firstTurn = false;
      cantDrawThisTurn = false;
      
      // ìƒíƒœ ê°ì†Œ
      block = 0;
      weak = Math.max(0, weak - 1);
      vulnerable = Math.max(0, vulnerable - 1);
      
      // ë… ì²˜ë¦¬
      if (poison > 0) {
        hp -= poison;
        poison--;
        addCombatLog(`ë… â†’ ${poison + 1} ë°ë¯¸ì§€`, 'dmg');
        if (hp <= 0) {
          defeat();
          return;
        }
      }
      
      // ì•…ë§ˆí˜•ìƒ
      if (powers.demon) {
        strength += powers.demon;
        addCombatLog(`ì•…ë§ˆí˜•ìƒ â†’ í˜+${powers.demon}`);
      }
      
      // í–‰ë³µí•œ ê½ƒ
      const flower = relics.find(r => r.energyEvery);
      if (flower) {
        flower.turnCount = (flower.turnCount || 0) + 1;
        if (flower.turnCount >= flower.energyEvery) {
          flower.turnCount = 0;
          energy++;
          addCombatLog(`í–‰ë³µí•œ ê½ƒ â†’ ì—ë„ˆì§€+1`);
        }
      }
      
      // ì  ìƒíƒœ ì´ˆê¸°í™”
      enemies.forEach(e => {
        if (e.hp <= 0) return;
        e.block = 0;
        e.weak = Math.max(0, e.weak - 1);
        e.vulnerable = Math.max(0, e.vulnerable - 1);
        e.strength += e.ritual || 0;
        e.intent = e.atks[rand(0, e.atks.length - 1)];
      });
      
      // ì†íŒ¨ ë²„ë¦¬ê³  ë“œë¡œìš°
      discardPile = discardPile.concat(hand);
      hand = [];
      energy = maxEnergy;
      
      for (let i = 0; i < 5; i++) drawCard();
      
      animating = false;
      gameMsg = `í„´ ${turn}`;
      render();
    }

    function combatVictory() {
      aiMsg = 'ì ì„ ë¬¼ë¦¬ì³¤ìŠµë‹ˆë‹¤!';
      gameMsg = '';
      combatLogs = [];
      
      // ë¶ˆíƒ€ëŠ” í”¼
      relics.forEach(r => { 
        if (r.heal) hp = Math.min(maxHp, hp + r.heal); 
      });
      
      // ë¼ˆì— ë¶™ì€ ê³ ê¸°
      const meat = relics.find(r => r.lowHpHeal);
      if (meat && hp <= maxHp * 0.5) {
        hp = Math.min(maxHp, hp + meat.lowHpHeal);
      }
      
      const enemy = enemies[0];
      const isBoss = enemy.boss;
      const isElite = enemy.elite;
      
      rewardGold = isBoss ? rand(95, 105) : isElite ? rand(25, 35) : rand(10, 20);
      
      // ì¹´ë“œ ë³´ìƒ
      const pool = Object.keys(CARDS).filter(k => k !== 'strike' && k !== 'defend');
      rewardCards = shuffle(pool).slice(0, 3).map(k => createCard(k));
      
      // í¬ì…˜ (40% í™•ë¥ )
      const potionPool = Object.keys(POTIONS);
      rewardPotion = Math.random() < 0.4 ? { ...POTIONS[potionPool[rand(0, potionPool.length - 1)]], uid: uid() } : null;
      
      // ì—˜ë¦¬íŠ¸/ë³´ìŠ¤ ë ë¦­
      if (isElite || isBoss) {
        const ownedKeys = relics.map(r => r.key);
        const relicPool = Object.keys(RELICS).filter(k => !ownedKeys.includes(k));
        if (relicPool.length > 0) {
          const key = relicPool[rand(0, relicPool.length - 1)];
          rewardRelic = { ...RELICS[key], key, uid: uid() };
        }
      }

      render();
      
      setTimeout(() => {
        if (isBoss && floor >= 13) {
          victory();
        } else {
          state = 'reward';
          render();
        }
      }, 800);
    }

    function collectGold() { gold += rewardGold; rewardGold = 0; render(); }
    function collectPotion() { 
      if (rewardPotion && potions.length < 3) potions.push(rewardPotion); 
      rewardPotion = null; 
      render(); 
    }
    function collectRelic() {
      if (rewardRelic) relics.push(rewardRelic);
      rewardRelic = null;
      render();
    }
    function selectRewardCard(i) { deck.push(rewardCards[i]); rewardCards = []; render(); }
    function skipRewardCard() { rewardCards = []; render(); }
    function finishReward() { 
      rewardCards = []; rewardGold = 0; rewardPotion = null; rewardRelic = null;
      state = 'map'; 
      gameMsg = '';
      autoSave(); 
      render(); 
    }

    function usePotion(i) {
      const p = potions[i];
      if (!p) return;
      
      if (state !== 'combat' && (p.dmg || p.str || p.dex || p.weakAll || p.poison || p.energy)) {
        gameMsg = 'ì „íˆ¬ ì¤‘ì—ë§Œ ì‚¬ìš© ê°€ëŠ¥!';
        render();
        return;
      }
      
      potions.splice(i, 1);
      
      if (p.dmg) {
        const e = enemies.find(en => en.hp > 0);
        if (e) {
          const absorbed = Math.min(p.dmg, e.block);
          e.block -= absorbed;
          e.hp -= (p.dmg - absorbed);
          gameMsg = `${p.name}! ${p.dmg} ë°ë¯¸ì§€!`;
          addCombatLog(gameMsg, 'dmg');
          setTimeout(() => checkEnemyDeath(), 300);
        }
      }
      if (p.block) { 
        gainBlock(p.block); 
        gameMsg = `${p.name}! ${p.block} ë°©ì–´!`; 
        addCombatLog(gameMsg, 'block');
      }
      if (p.str) { 
        strength += p.str; 
        gameMsg = `${p.name}! í˜+${p.str}!`; 
      }
      if (p.dex) { 
        dexterity += p.dex; 
        gameMsg = `${p.name}! ë¯¼ì²©+${p.dex}!`; 
      }
      if (p.healPct) { 
        const heal = Math.floor(maxHp * p.healPct);
        hp = Math.min(maxHp, hp + heal); 
        gameMsg = `${p.name}! ${heal} íšŒë³µ!`; 
        addCombatLog(gameMsg, 'heal');
      }
      if (p.weakAll) {
        enemies.forEach(e => { if (e.hp > 0) e.weak += p.weakAll; });
        gameMsg = `${p.name}! ì  ì „ì²´ ì•½í™”${p.weakAll}!`;
      }
      if (p.poison) {
        const e = enemies.find(en => en.hp > 0);
        if (e) {
          e.poison = (e.poison || 0) + p.poison;
          gameMsg = `${p.name}! ë… ${p.poison}!`;
        }
      }
      if (p.energy) {
        energy += p.energy;
        gameMsg = `${p.name}! ì—ë„ˆì§€+${p.energy}!`;
      }
      if (p.randomPower) {
        const powers = ['strength', 'endBlock', 'strPerTurn'];
        const chosen = powers[rand(0, powers.length - 1)];
        if (chosen === 'strength') strength += 1;
        else if (chosen === 'endBlock') powers.metal = (powers.metal || 0) + 3;
        else powers.demon = (powers.demon || 0) + 1;
        gameMsg = `${p.name}! ëœë¤ íŒŒì›Œ íšë“!`;
      }
      
      render();
    }

    // ì´ë²¤íŠ¸
    function triggerEvent() { 
      const pool = EVENTS.filter(e => e.id !== 'bigFish' || !currentEvent || currentEvent.id !== 'bigFish');
      currentEvent = pool[rand(0, pool.length - 1)]; 
      aiMsg = 'ë¬´ì–¸ê°€ ë°œê²¬!'; 
      gameMsg = '';
      state = 'event'; 
    }
    
    function chooseEvent(i) {
      const c = currentEvent.choices[i];
      let msg = '';
      
      if (c.healPct) { 
        const heal = Math.floor(maxHp * c.healPct);
        hp = Math.min(maxHp, hp + heal);
        msg = `HP ${heal} íšŒë³µ!`;
      }
      if (c.maxHp) { maxHp += c.maxHp; hp += c.maxHp; msg = `ìµœëŒ€ HP +${c.maxHp}!`; }
      if (c.maxHpLoss) { maxHp -= c.maxHpLoss; hp = Math.min(hp, maxHp); msg = `ìµœëŒ€ HP -${c.maxHpLoss}...`; }
      if (c.gold) { gold += c.gold; msg = `ê¸ˆí™” +${c.gold}!`; }
      if (c.damage) { hp -= c.damage; msg += ` HP -${c.damage}`; }
      if (c.relic || c.rareRelic) {
        const ownedKeys = relics.map(r => r.key);
        const pool = Object.keys(RELICS).filter(k => !ownedKeys.includes(k));
        if (pool.length > 0) {
          const key = pool[rand(0, pool.length - 1)];
          relics.push({ ...RELICS[key], key, uid: uid() });
          msg = `${RELICS[key].name} íšë“!`;
        }
      }
      if (c.relicKey) {
        const ownedKeys = relics.map(r => r.key);
        if (!ownedKeys.includes(c.relicKey)) {
          relics.push({ ...RELICS[c.relicKey], key: c.relicKey, uid: uid() });
          msg = `${RELICS[c.relicKey].name} íšë“!`;
        }
      }
      if (c.upgradeRandom) {
        const upgradeable = deck.filter(card => !card.upgraded);
        if (upgradeable.length > 0) {
          upgradeCard(upgradeable[rand(0, upgradeable.length - 1)]);
          msg = 'ëœë¤ ì¹´ë“œ ì—…ê·¸ë ˆì´ë“œ!';
        }
      }
      if (c.removeRandom && deck.length > 5) {
        deck.splice(rand(0, deck.length - 1), 1);
        msg = 'ëœë¤ ì¹´ë“œ ì œê±°!';
      }
      if (c.randomWheel) {
        const effects = [
          () => { gold += 100; return 'ê¸ˆí™” +100!'; },
          () => { hp = Math.min(maxHp, hp + Math.floor(maxHp * 0.25)); return 'HP 25% íšŒë³µ!'; },
          () => { hp -= 10; return 'HP -10...'; },
          () => { maxHp += 5; hp += 5; return 'ìµœëŒ€ HP +5!'; },
          () => { const u = deck.filter(c => !c.upgraded); if (u.length) upgradeCard(u[0]); return 'ì¹´ë“œ ì—…ê·¸ë ˆì´ë“œ!'; }
        ];
        const effect = effects[rand(0, effects.length - 1)];
        msg = effect();
      }
      if (c.combat === 'elite') {
        currentEvent = null;
        startCombat('elite');
        return;
      }
      
      gameMsg = msg || 'ì•„ë¬´ ì¼ë„ ì¼ì–´ë‚˜ì§€ ì•Šì•˜ë‹¤';
      currentEvent = null;
      render();
      setTimeout(() => { state = 'map'; gameMsg = ''; autoSave(); render(); }, 1500);
    }

    // íœ´ì‹ì²˜
    function triggerRest() {
      aiMsg = 'ëª¨ë‹¥ë¶ˆì˜ ì˜¨ê¸°...';
      gameMsg = '';
      state = 'rest';
    }
    
    function restHeal() {
      const heal = Math.floor(maxHp * 0.3);
      hp = Math.min(maxHp, hp + heal);
      gameMsg = `HP ${heal} íšŒë³µ!`;
      render();
      setTimeout(() => { state = 'map'; gameMsg = ''; autoSave(); render(); }, 1000);
    }
    
    function restUpgrade() {
      showUpgrade();
    }

    // ìƒì 
    function triggerShop() {
      const cardPool = Object.keys(CARDS).filter(k => k !== 'strike' && k !== 'defend');
      const cards = shuffle(cardPool).slice(0, 6).map(k => ({
        item: createCard(k),
        price: CARDS[k].type === 'power' ? rand(100, 160) : rand(50, 120),
        sold: false
      }));
      
      const potionPool = Object.keys(POTIONS);
      const pots = shuffle(potionPool).slice(0, 3).map(k => ({
        item: { ...POTIONS[k], key: k, uid: uid() },
        price: rand(40, 80),
        sold: false
      }));
      
      const ownedRelics = relics.map(r => r.key);
      const relicPool = Object.keys(RELICS).filter(k => !ownedRelics.includes(k));
      const shopRelics = shuffle(relicPool).slice(0, 2).map(k => ({
        item: { ...RELICS[k], key: k, uid: uid() },
        price: rand(150, 250),
        sold: false
      }));
      
      shopItems = { 
        cards, 
        potions: pots, 
        relics: shopRelics,
        removePrice: 75,
        removeUsed: false
      };
      aiMsg = 'ìƒì¸ì˜ ë¯¸ì†Œ...';
      gameMsg = '';
      state = 'shop';
    }
    
    function buyCard(i) {
      const it = shopItems.cards[i];
      if (!it || it.sold) return;
      if (gold < it.price) { gameMsg = 'ê¸ˆí™” ë¶€ì¡±!'; render(); return; }
      gold -= it.price;
      deck.push(it.item);
      it.sold = true;
      gameMsg = `${it.item.name} êµ¬ë§¤!`;
      render();
    }
    
    function buyPotion(i) {
      const it = shopItems.potions[i];
      if (!it || it.sold) return;
      if (gold < it.price) { gameMsg = 'ê¸ˆí™” ë¶€ì¡±!'; render(); return; }
      if (potions.length >= 3) { gameMsg = 'í¬ì…˜ ê°€ë“!'; render(); return; }
      gold -= it.price;
      potions.push(it.item);
      it.sold = true;
      gameMsg = `${it.item.name} êµ¬ë§¤!`;
      render();
    }
    
    function buyRelic(i) {
      const it = shopItems.relics[i];
      if (!it || it.sold) return;
      if (gold < it.price) { gameMsg = 'ê¸ˆí™” ë¶€ì¡±!'; render(); return; }
      gold -= it.price;
      relics.push(it.item);
      it.sold = true;
      gameMsg = `${it.item.name} íšë“!`;
      render();
    }
    
    function shopRemoveCard() {
      if (shopItems.removeUsed) return;
      if (gold < shopItems.removePrice) { gameMsg = 'ê¸ˆí™” ë¶€ì¡±!'; render(); return; }
      gold -= shopItems.removePrice;
      showRemove();
    }
    
    function exitShop() { 
      state = 'map'; 
      gameMsg = ''; 
      autoSave();
      render(); 
    }

    // ë³´ë¬¼
    function triggerTreasure() {
      const ownedKeys = relics.map(r => r.key);
      const pool = Object.keys(RELICS).filter(k => !ownedKeys.includes(k));
      
      if (!pool.length) { 
        gold += 50;
        gameMsg = 'ëŒ€ì‹  ê¸ˆí™” 50ê°œë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤!';
        aiMsg = '';
        render();
        setTimeout(() => { state = 'map'; gameMsg = ''; autoSave(); render(); }, 1500);
        return; 
      }
      
      const k = pool[rand(0, pool.length - 1)];
      relics.push({ ...RELICS[k], key: k, uid: uid() });
      gameMsg = `${RELICS[k].name} íšë“!`;
      aiMsg = 'ë³´ë¬¼ ë°œê²¬!';
      render();
      setTimeout(() => { 
        state = 'map'; 
        gameMsg = ''; 
        autoSave();
        render(); 
      }, 1500);
    }

    function victory() { state = 'victory'; aiMsg = ''; gameMsg = ''; localStorage.removeItem('slayv2-auto'); render(); }
    function defeat() { aiMsg = 'ì–´ë‘  ì†ìœ¼ë¡œ...'; gameMsg = ''; state = 'defeat'; localStorage.removeItem('slayv2-auto'); render(); }
    function goToMenu() { state = 'menu'; aiMsg = ''; gameMsg = ''; render(); }

    // ì´ˆê¸°í™”
    render();
  </script>

</body>
</html>
